<!-- vim: set noexpandtab shiftwidth=4 wrap linebreak filetype=mediawiki: -->
{{#set: title=第11章: コンフィグオプションリファレンス}}
{{Nav
|prev=LKN/Chapter10
|next=LKN/AppendixA
}}

= 第11章: コンフィグオプションリファレンス =

この章では、''make config''あるいはグラフィカルなコンフィグを実行するときに最も重要になるオプションを紹介します。この章の内容の大半はカーネルに付属のドキュメンテーションをベースにしています。このドキュメンテーションはカーネル開発者によって書かれたもので、GPLで公開されています。

== EXPERIMENTAL ==

開発中の、または未完成のコードやドライバについてユーザに尋ねる

ネットワークドライバやファイルシステム、ネットワークプロトコルなどLinuxが対応する様々なものの中には、開発レベルのものが含まれます。これらは機能、安定性、あるいはテスト状況がまだ十分高まっておらず、一般使用には向かないもので、開発者の間では「アルファ」と言われるものです。普通、「なぜちゃんと動かないの？」というメールが山のように届いてしまうのを避けるため、これらの機能は何も知らない一般人が広く使ってしまわないようにしてあります。が、これらのテストランとバグレポートはカーネル開発者には歓迎されています。ただし正常に動作しなかったり、不安定だったりするかも知れない事は念頭に置いておいて下さい。（バグレポートを出す前にREADME、MAINTAINERS、REPORTING-BUGS、Documentation/BUG-HUNTINGとDocumentation/oops-tracing.txtの各種ドキュメントを参照して下さい。）

このオプションはまた、廃止されたドライバも有効にします。これには既に新しいものによって置き換えられたドライバと、置き換えられる予定のドライバが含まれます。

機能の開発を手伝うつもりか、あるいは古いドライバを使う必要があるときを除き、このオプションはnoにしておくべきです。yesにするとこれらの機能を使うかどうかの選択肢が与えられます。

このオプション自体は選択肢を提供するだけで、実質的な効果はありません。

== LOCALVERSION ==

カーネルのリリースバージョンにローカルバージョン番号を付加します。

このオプションを使うとカーネルバージョン文字列に独自の文字列を付加できます。これは''uname''コマンドを実行した時などに出力されます。指定した文字列はオブジェクトとソースツリー内にある、''localversion''で始まるファイル名に付加されます。最長で64文字まで指定できます。

== AUDIT ==

SELinuxなどのサブシステムで利用できる監視インフラを有効にします。（SELinuxではavcメッセージをログするために必要です。）

== IKCONFIG ==

このオプションをyesにすると''.config''の内容がまるごとカーネルの中に保存されます。この情報は''scripts/extract-ikconfig''スクリプトを使ってカーネルイメージから抽出することができ、別のカーネルのビルドに流用できます。また、実行中のカーネルからは''/proc/config.gz''で抽出できます。

== EMBEDDED ==

小規模システムのために標準的なカーネルをコンフィグします。

基本的なカーネルオプションをオフにしたり変更したりできるようになります。「非標準的な」カーネルを許容できる特殊な環境のためのオプションです。ブートさえできないようなカーネルを作ってしまいがちですので、上級者でない方は触らないほうがいいでしょう。

このオプション自体は他の選択肢を提供するだけで、実質的な効果はありません。

== MODULES ==

モジュールサポートを有効にします。

カーネルモジュールは実行中のカーネルに読み込めるコンパイル済みのコードの塊です。このオプションをONにしておくとカーネルの部分部分をモジュールとしてビルドできるようになります（yesの代わりにMを指定する）。ブート時に必要ない、あまり使用しない機能のためによく使われます。詳しくは{{Link|LKN/Chapter4}}および''modprobe''、''lsmod''、''modinfo''、''insmod''、''rmmod''のmanpageを参照して下さい。

yesにしておくと、後に''make modules_install''を実行してモジュールをインストール（''/lib/modules''配下に配置）する必要があります。

== IOSCHED_NOOP ==

No-op I/Oスケジューラを使います。

No-op I/Oスケジューラは、最小限のマージとソートしかしないミニマルなスケジューラです。主にメモリデバイスなど、ディスクベースでないブロックデバイスや、その他の特殊なハードウェア/ソフトウェア環境で、独自のスケジューリングを実行するためカーネルからの手助けがあまり必要ないときに使用されます。

== IOSCHED_AS ==

Anticipatory I/Oスケジューラを使います。

Anticipatory I/Oスケジューラはデフォルトのディスクスケジューラです。大半の環境ではこれが適していますが、後述のDeadlineスケジューラと比べるとかなり大規模で複雑です。またデータベースを使用する際などはパフォーマンスもあまり優れません。

== IOSCHED_DEADLINE ==

Deadline I/Oスケジューラを使います。

Deadline I/Oスケジューラはシンプルでコンパクトな構成になっています。大抵の場合、Anticipatoryスケジューラと同等に良い仕事をしてくれますし、データベースを使用する際などはこちらのほうが優れています。シングルプロセスでのI/OではAnticipatoryとほぼ同じ動作をするので、これも良い選択肢です。

== IOSCHED_CFQ ==

CFQ I/Oスケジューラを使います。

CFQ I/Oスケジューラは各プロセスに均等に帯域幅を分け与えようとします。主にデスクトップ向けにそれなりの環境を提供してくれます。

== SMP ==

対称型マルチプロセッシング。

このオプションでマルチCPUを有効にできます。マシンにCPUが一台だけなら、noを選びます。複数のCPUが搭載されているならyesです。

noを選ぶと、シングルプロセッサのマシンでもマルチプロセッサのマシンでもカーネルは動作しますが、使うCPUは1つだけになります。yesを選んでも、大体のシングルプロセッサマシンでカーネルは動作しますが、動作しないこともあります。シングルプロセッサマシンではnoにしておいたほうが高速に動作します。

注意すべきは、yesを選んだ上でプロセッサファミリーとして586またはPentiumを選択すると、486アーキテクチャでは動作しない点です。また、PProアーキテクチャ用のマルチプロセッサカーネルもPentiumベースのボードでは一部動作しない場合があります。

''Documentation/smp.txt''、''Documentation/i386/IO-APIC.txt''、''Documentation/nmi_watchdog.txt''、および''http://www.tldp.org/docs.html#howto''も参照して下さい。

== M386 ==

最適化のためにCPUの種類を選択します。全てのx86 CPUで動作する（が、最速ではない）カーネルにするには386を選択しておきます。

選択したものより古いアーキテクチャでは必ずしも動作するとは限りません。例えばPentiumに最適化されたカーネルはPProでは動作しますが、i486では動作しないかも知れません。

高速化のために推奨の設定は以下のとおりです。

;386
:  AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI 486DLC/DLC2, UMC 486SX-SあるいはNexGenNx586プロセッサ向け。386クラスのマシンでは386カーネルしか動作しません。
;486
:  AMD/Cyrix/IBM/Intel 486DX/DX2/DX4、SL/SLC/SLC2/SLC3/SX/SX2、UMC U5DあるいはU5S向け。
;Pentium-Classic
:  Intel Pentium向け。
;Pentium-MMX
:  Intel Pentium MMX向け。
;Pentium-Pro
:  Intel Pentium Pro向け。
;Pentium-II
:  Intel Pentium IIかCoppermine以前のCeleron向け。
;Pentium-III
:  Intel Pentium IIIかCoppermine Celeron向け。
;Pentium-4
:  Intel Pentium 4かP4ベースのCeleron向け。
;K6
:  AMD K6、K6-II、K6-III（別名K6-3D）向け。
;Athlon
:  AMD K7ファミリー（Athlon/Duron/Thunderbird）向け。
;Crusoe
:  Transmeta Crusoe向け。
;Efficeon
:  Transmeta Efficeon向け。
;Winchip-C6
:  元祖IDT Winchip向け。
;Winchip-2
:  IDT Winchip 2向け。
;Winchip-3
:  3DNow!機能付きのIDT Winchip向け。
;GeodeGX1
:  Geode GX1 (Cyrix MediaGX)向け。
;Geode GX/LX
:  AMD Geode GXあるいはLX向け。
;CyrixIII/VIA C3
:  VIA Cyrix III あるは VIA C3向け。
;VIA C3-2
:  VIA C3-2 "Nehemian" （モデル9以上）向け。
よく分からない場合は386でOKです。

== X86_GENERIC ==

選択したx86変種用の最適化に加え、一般的な最適化を行います。選択しておくと選択したものでないx86 CPUにおいてパフォーマンスが向上します。ディストリビューションなどの配布者向けのオプションです。

== NR_CPUS ==

CPU数の上限。

このカーネルがサポートするCPU数の上限を指定できます。最大は255で最小は2です。

CPUをひとつ多くサポートするたびにカーネルイメージを8KB消費するので、メモリ節約のためのオプションです。

== SCHED_SMT ==

SMT (HyperThreading) スケジューラ。

SMTスケジューラを使うとHyperThreading搭載Intel Pentium 4のスケジューリングを改善しますが、そこかしこでオーバーヘッドが増加します。

== PREEMPT_NONE ==

強制プリエンプションなし（サーバ向け）。

従来のプリエンプションモデルで、スループットの最大化を狙ったものです。あまり遅延が問題になることはありませんが、たまに大きな遅延が発生します。

サーバや科学計算のためのシステムならこれがお勧めです。

== PREEMPT_VOLUNTARY ==

ボランタリ・プリエンプション（デスクトップ向け）。

カーネルのコードに明示的プリエンプションを追加することでカーネルのレイテンシを低減することを狙ったものです。多少スループットを犠牲にしてアプリケーションのレスポンスを向上させます。

このオプションが有効だと、優先度の低いプロセスは、たとえカーネルモードでシステムコールを実行していても自発的にプリエンプションを行えるようになります。これによって見かけ上のレスポンスが良くなります。

デスクトップシステムならこれがお勧めです。

== PREEMPT ==

プリエンプション可能なカーネル（デスクトップ向け）。

カーネル内のほぼ全てのコードをプリエンプション可能にすることでカーネルのレイテンシを低減します。このオプションが有効だと、優先度の低いプロセスは、たとえカーネルモードでシステムコールを実行していても自発的にプリエンプションを行えるようになります。これによって見かけ上のレスポンスがよくなります。多少スループットを犠牲にし、カーネルにランタイムオーバーヘッドが加わります。

デスクトップか組み込みシステムで、レイテンシの要求がミリ秒単位の場合はこれがお勧めです。

== PREEMPT_BKL ==

Big Kernel Lockプリエンプションを有効にしてレイテンシを低減します。

デスクトップならONがいいでしょう。

== NOHIGHMEM ==

Linuxはx86システムでは64GBまでメモリを使用できますが、32-bit x86プロセッサのアドレス空間は4GBしかありません。つまり、大容量の物理メモリがあっても全部をカーネルが使うことはできないということです。こうして恒常的にマップされない物理メモリをHigh memoryと呼びます。

1GBを超えるメモリを積んだマシンでは動かさないと分かっているならoffで構いません（デフォルトで、普通はこれで大丈夫です）。すると、メモリは3GB/1GBに分かれます。各プロセスからは3GBの仮想メモリ空間が見えて、仮想メモリ4GBのうちの残りをカーネルができるだけ物理メモリにマッピングします。

マシンに1〜4GBの物理メモリを搭載しているなら4GBを選びます。

マシンに搭載しているメモリが4GBを超える場合、64GBを選びます。するとPAE (Physical Address Extension) モードが有効になります。PAEはIA32プロセッサで3レベルページングを実装しています。PAEはLinuxで完全にサポートされており、PAEモードはPentium Pro以降のIntelプロセッサなら利用可能です。

{{LKN/Tip| 64GBを選ばないと、PAE非対応のCPUでは起動しません。}}

物理メモリの実際の容量は自動検出できますし、コマンドラインオプション''mem=256M''などでして出来ます（コマンドラインオプションについては{{Link|LKN/Chapter9}}を参照）。

よく分からない場合はoffで大丈夫です。

== HIGHMEM4G ==

32bitプロセッサで1〜4GBの物理メモリを搭載している場合は選択します。

== HIGHMEM64G ==

32bitプロセッサで4GB以上の物理メモリを搭載している場合は選択します。

== FLATMEM_MANUAL ==

Linuxによるメモリ管理の方法を変更できます。普通、ここではFLATMEMしか選択できないはずです。これは正常で、正しいオプションです。

NUMAやメモリホットプラグなどを使用するユーザは別のオプションが選べるでしょう。DISCONTIGMEMは成熟した、よくテストされたシステムですが、メモリホットプラグとは互換性がありませんし、SPARSEMEMと比べるとパフォーマンス面で劣ります。SparseとDiscontiguousメモリのどちらかよく分からない場合はdiscontiguousを選びましょう。

よく分からない場合はこれを選択しておきます。

== DISCONTIGMEM_MANUAL ==

Discontiguousなメモリシステムの場合はFLATよりもこちらのほうが適しています。これらのシステムでは物理アドレス空間に穴があり、こちらのほうがこれらの穴をより効率的に扱えるからです。ただし、大多数のシステムはかなりフラットなアドレス空間を持っており、このオプションのオーバーヘッドによってパフォーマンスが低下することもよくあります。

NUMAの場合はこれしか選択肢がないことが多いです。

よく分からない場合はFLATを選択しておきましょう。

== SPARSEMEM_MANUAL ==

メモリホットプラグなどのシステムではこれしか選択肢がないと思います。

その他のシステムではDiscontiguousの代替として選択できます。こちらのほうがパフォーマンスが高く、コードもシンプルですが、新しくて実験的です。

よく分からない場合はDISCONTIGかFLATを選択しておきましょう。

== SECCOMP ==

信頼できないバイトコードを計算するアプリケーションを利用する際に便利なオプションです。Seccompではパイプなどを使ってこれらのアプリケーションを独自のメモリ空間に隔離することができます。''/proc/pid/seccomp''でseccompを有効にすると無効にすることは出来ず、タスクはseccompモードに従ってごく一部のシステムコールしか実行できなくなります。

よく分からない場合はyesにしておきましょう。組込みシステムではnoが適しています。

== KEXEC ==

kexecは実行中のカーネルをシャットダウンして別のカーネルを起動する実験的なシステムコールです。リブートと似ていますが、ファームウェアに依存しません。また、リブートと同様、Linuxに限らずどんなカーネルでも起動できます。

kexecという名前はexecシステムコールに似ているところに由来します。

この機能はもしかすると正常に動作しないかも知れません。その場合、デバイスホットプラグを有効にしてみてください。執筆時点ではハードウェアインタフェースが非常に流動的なのでなにもおすすめすることはできません。

== HOTPLUG_CPU ==

yesにするとCPUのon/offができるようになり、SMPシステムでサスペンドが利用できます。CPUは''/sys/devices/system/cpu''インタフェースで操作できます。

== PM ==

電源管理。

PMを有効にするとマシンの一部をシャットオフしたり節電スリープモードに落とすことができます。これには2つの競合する標準が存在します。APMとACPIです。このどちらかを使いたい場合はyesにしておきます。

電源管理は主にラップトップで重要になります。ラップトップをお持ちなら、Linux Laptopホームページ(http://www.linux-on-laptops.com)、Tuxmobil-Linux on Mobile Computers (http://tuxmobil.org)、およびBattery Powered Linux (http://www.tldp.org/docs.html#howto) も参考にして下さい。

たとえここでnoを選択してもx86アーキテクチャならシステムがアイドルであるときはHLT命令を出してプロセッサをスリープに落とします。

== SOFTWARE_SUSPEND ==

サスペンドを有効にします。

サスペンドすると、イメージがスワップ領域に保存されます。次回ブート時に''resume=/dev/swappartition''パラメータを指定するとそのイメージを使ってメモリの状態をリストアし、レジュームすることができます。サスペンドしたがレジュームしたくない場合は''noresume''パラメータを指定します。ただし、パーティションはfsckされるのでmkswapを実行する必要があります。

今回だけレジュームせずにブートし、次回にレジュームすることもできますが、その間にはサスペンドに塩湯したスワップパーティションやスワップファイルは使用不可になります。この場合も、ディスク上のバッファが保存したものと一致しなくなるリスクがあります。

より詳しくは''Documentation/power/swusp.txt''を参照して下さい。


== ACPI ==

ACPI (Advanced Configuration and Power Interface)サポートを有効にします。ACPIを使うには対応したハードウェアとファームウェア、およびOSPMソフトウェアが必要です。これでカーネルのサイズが約70KBほど増大します。

LinuxのACPIは、従来のコンフィグ・電源管理インタフェースの代替としてロバストで高機能な
ものとなっています。従来のとは、たとえばPnP BIOS、MPS、APMなどです。もしACPIとAPMが両方有効になっていれば、先にロードされたほうが使われます。

ACPIのSourceForgeプロジェクトページ http://sourceforge.net/projects/acpi にて最新のソースコード、ドキュメンテーション、ツール、メーリングリスト他のリソースが手に入ります。

LinuxのACPIはIntel社のACPI Component Architectureに従っています。詳しくは http://developer.intel.com/technology/iapc/acpi を参照して下さい。

ACPIはオープンな仕様で、Compaq、Intel、Microsoft、PhoenixおよびToshibaによって策定されました。仕様は http://www.acpi.info で公開されています。

== CPU_FREQ ==

CPU周波数スケーリングを使うとCPUのクロックをオンザフライで変更できます。CPUクロックが低いほど消費電力も少なくなるので、節電の効果があります。

これだけでは自動的にCPUクロックを変更してはくれません。後述する動的なCPUFreqポリシーガバナーを使うか、別のユーザスペースツールを使う必要があります。

詳しくは''Documentation/cpu-freq''を参照して下さい。

== CPU_FREQ_DEFAULT_GOV_PERFORMANCE ==

CPUFreqのパフォーマンス重視型ガバナーを使います。つまりCPUの対応する最高周波数を常に使います。

== CPU_FREQ_DEFAULT_GOV_USERSPACE ==

CPUFreqのユーザスペースガバナーを使います。これを使うと周波数を手動で、あるいはユーザスペースプログラムを使って動的に設定することができます。

== CPU_FREQ_GOV_PERFORMANCE ==

このガバナーはCPU周波数を常に最高に設定します。

== CPU_FREQ_GOV_POWERSAVE ==

このガバナーはCPU周波数を常に最低に設定します。

== CPU_FREQ_GOV_USERSPACE ==

このガバナーでは周波数を手動で、あるいはユーザスペースプログラムを使って動的に設定できます。

== CPU_FREQ_GOV_ONDEMAND ==

この動的なガバナーはCPUをポーリングし、仕様状況に応じて周波数を変更します。このガバナーが使えるかどうかは、CPUが高速周波数切替（低遅延での周波数切替）に対応しているかによります。

== CPU_FREQ_GOV_CONSERVATIVE ==

このガバナーは目的もソースコードもOndemandに似ていますが、バッテリーで動作するシステムに最適化されている点が違います。周波数は急に100に飛んだりせず、緩やかに上昇・下降します。

ラップトップ、PDA、あるいはAMD64ベースのマシンを使うなら、周波数切替のレイテンシの問題がありますので、このガバナーをお勧めします。デスクトップならばOndemandガバナーのほうが適しているでしょう。

== PCI ==

PCIは内部デバイスや追加デバイスがプロセッサとやりとりするためのバスシステムです。非常に一般的で、ほとんどのマシンに搭載されています。

特に理由がない限りyesで大丈夫です。

== PCCARD ==

PCMCIA/PCカードを使いたいならyesにします。これらはクレジットカード大のデバイスで、主にモデムやネットワークカード、ハードディスクなどに使われます。

その内訳は2種類あります。16bitのPCMCIAと32bitのCardBusです。

== PCMCIA ==

16bitのPCMCIAカードをサポートします。古いPCカードはだいたいが16bitのPCMCIAなので、32bitのCardBusしか使わないと分かりきっているとき以外はyesにしておきましょう。

通常、カードにともなってソフトウェアが必要になります。詳しくは''Documentation/Changes''を参照して下さい。

== CARDBUS ==

CardBusは32bit対応のPCカードです。最近のPCカードにはCardBusのものが増えてきました。

32bitのPCカードを使うにはCardBus互換のホストブリッジが必要です。ほぼすべてのPCMCIAブリッジが対応していますし、"yenta互換"でもありますので、そのオプションも有効化します。

== NET ==

ネットワーキング。

特殊な理由がないかぎりyesにしておきましょう。これは、スタンドアローンマシンを作るにしても、一部のプログラムはネットワーキングサポートがないと動作しないからです。

古いカーネルからアップグレードするならネットワーキングツールもアップグレードしたほうがいいかもしれません。これらは''net-tools''パッケージに含まれます（具体的には''Documentation/Changes''を参照して下さい）。

Linuxネットワーキングの基礎についてはNET-HOWTO (http://www.tldp.org/docs.html#howto) を一読することを強くお勧めします。

== UNIX ==

Unixソケット。

yesにするとUnixソケットが使えます。Unixソケットはネットワーク接続するための標準的なメカニズムです。X Window Systemをはじめとしsyslog、udevなどの基本的なプログラムがUnixソケットを利用しますので、スタンドアローンマシンを作るにしても、yesにしておくことを強くお勧めします。

== INET ==

TCP/IPネットワーク。

インターネットおよびほとんどのローカルEthernetで使われるプロトコルです。X Window Systemなどはこれに依存しますので、スタンドアローンマシンを作るにしても有効にしておいたほうがいいでしょう。これによってカーネルのサイズが114KBほど増大します。

Linuxネットワーキングの基礎についてはNET-HOWTO (http://www.tldp.org/docs.html#howto) を一読することを強くお勧めします。

== IP_ADVANCED_ROUTER ==

Linuxマシンをルータ（ネットワークパケットを転送する役割）として利用したいならyesにします。yesにするとさらに細かいオプションが指定できます。

このオプション自体は他の選択肢を提供するだけで、実質的な効果はありません。

ルータとして使うにはIPフォワードを有効にしておく必要があります。そのためには
 $ echo "1" > /proc/sys/net/ipv4/ip_forward
を実行します。

IPフォワードを有効にするとrp_filterも有効になります。これはパケットのソースアドレスがネットワークインターフェースと食い違っている場合にパケットを拒否する機能で、IPスプーフィング対策になります。セキュリティ上の便益がありますが、非対称ルーティング（ローカルからホスト行きのパケットが、ホストからローカル行きのパケットと別のルートをたどる）をする場合や、IPアドレスを複数持つルータでないマシンとして動作させる場合は問題に成ることがあります。rp_filterをオフにするには
 $ echo 0 > /proc/sys/net/ipv4/conf/device/rp_filter
あるいは
 $ echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
を実行します。

== NETFILTER ==

パケットフィルタリング。

NetfilterはLinuxマシンを通過するネットワークパケットをフィルタしたり書き換えたりするフレームワークです。

Netfilterの最も一般的な利用法は、Linuxマシンを、ローカルネットワークをインターネットから保護するファイアウォールとして使う場合です。Netfilterで利用できるファイアウォール機能はパケットフィルタと呼ばれ、個々のネットワークパケットを種類、ソース、宛先などでフィルタすることができます。

もうひとつの種類はプロキシベースと呼ばれ、よりセキュアですがセットアップが面倒です。このタイプのものはネットワークのトラフィックをより厳重に監視し、手を加えます。また、上位プロトコルについても関知するのが特徴です。さらに、プロキシベースのファイアウォールはローカルクライアントで動作するプログラム自体に変更を加える必要があることが多くなっています。プロキシベースのファイアウォールはカーネルサポートを必要としませんが、通常はパケットフィルタと共に利用されるため、ここではyesを選んたほうがいいでしょう。

また、LinuxマシンをゲートウェイとしてローカルのPCをインターネットに接続させる場合も、yesを選びます。これはIPマスカレードと呼ばれます。ローカルネットワーク上のマシンが外部に何かを送信したい場合、Linuxマシンがそのマシンのふり（マスカレード）をして、つまりローカルマシンからのパケットを書き換えて送信します。また、復路でもこの動きをします。つまり、外部のホストが返事をしたとき、パケットを書き換えてローカルのマシンに転送するのです。こうしてローカルネットワークのマシンは外部からは全く見えないのに、外のホストと通信することができます。また、ポートフォワーディングという機能を使えばローカルネットワーク内で外部アクセスを受け入れるサーバを動かすこともできます。マスカレードはNAT (Network Address Translation)、あるいはPAT (Port Address Translation) とも呼ばれます。

Netfilterのもう一つの使い方はプロキシです。ローカルネットワークのマシンが外部に接続する際、透過的に別のサーバ（キャッシュプロキシサーバなど）に転送できます。

さらにもう一つの使い方は、ブリッジファイアウォールの構築です。パケットフィルタリングとブリッジを同時に利用するとiptablesはブリッジされたトラフィックを見ることができます。Ethernetなど低レベルプロトコルのフィルタリングを行うにはebtablesを使います（ブリッジNetfilter以下のコンフィグオプションです）。

Netfilterの各種モジュールには、従来のipmasqadm、ipchains、プロキシおよびポートフォワーディングに代わるものが存在します。具体的なパッケージについては''Documentation/Changes''のiptablesの項を参照して下さい。

マシンをルータとして使うならyes、そうでなければnoを選びましょう。

== NET_SCHED ==




<references/>


{{Nav
|prev=LKN/Chapter10
|next=LKN/AppendixA
}}
