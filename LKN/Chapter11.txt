<!-- vim: set noexpandtab shiftwidth=4 wrap linebreak filetype=mediawiki: -->
{{#set: title=第11章: コンフィグオプションリファレンス}}
{{Nav
|prev=LKN/Chapter10
|next=LKN/AppendixA
}}

= 第11章: コンフィグオプションリファレンス =

この章では、''make config''あるいはグラフィカルなコンフィグを実行するときに最も重要になるオプションを紹介します。この章の内容の大半はカーネルに付属のドキュメンテーションをベースにしています。このドキュメンテーションはカーネル開発者によって書かれたもので、GPLで公開されています。

== EXPERIMENTAL ==

開発中の、または未完成のコードやドライバについてユーザに尋ねる

ネットワークドライバやファイルシステム、ネットワークプロトコルなどLinuxが対応する様々なものの中には、開発レベルのものが含まれます。これらは機能、安定性、あるいはテスト状況がまだ十分高まっておらず、一般使用には向かないもので、開発者の間では「アルファ」と言われるものです。普通、「なぜちゃんと動かないの？」というメールが山のように届いてしまうのを避けるため、これらの機能は何も知らない一般人が広く使ってしまわないようにしてあります。が、これらのテストランとバグレポートはカーネル開発者には歓迎されています。ただし正常に動作しなかったり、不安定だったりするかも知れない事は念頭に置いておいて下さい。（バグレポートを出す前にREADME、MAINTAINERS、REPORTING-BUGS、Documentation/BUG-HUNTINGとDocumentation/oops-tracing.txtの各種ドキュメントを参照して下さい。）

このオプションはまた、廃止されたドライバも有効にします。これには既に新しいものによって置き換えられたドライバと、置き換えられる予定のドライバが含まれます。

機能の開発を手伝うつもりか、あるいは古いドライバを使う必要があるときを除き、このオプションはnoにしておくべきです。yesにするとこれらの機能を使うかどうかの選択肢が与えられます。

このオプション自体は選択肢を提供するだけで、実質的な効果はありません。

== LOCALVERSION ==

カーネルのリリースバージョンにローカルバージョン番号を付加します。

このオプションを使うとカーネルバージョン文字列に独自の文字列を付加できます。これは''uname''コマンドを実行した時などに出力されます。指定した文字列はオブジェクトとソースツリー内にある、''localversion''で始まるファイル名に付加されます。最長で64文字まで指定できます。

== AUDIT ==

SELinuxなどのサブシステムで利用できる監視インフラを有効にします。（SELinuxではavcメッセージをログするために必要です。）

== IKCONFIG ==

このオプションをyesにすると''.config''の内容がまるごとカーネルの中に保存されます。この情報は''scripts/extract-ikconfig''スクリプトを使ってカーネルイメージから抽出することができ、別のカーネルのビルドに流用できます。また、実行中のカーネルからは''/proc/config.gz''で抽出できます。

== EMBEDDED ==

小規模システムのために標準的なカーネルをコンフィグします。

基本的なカーネルオプションをオフにしたり変更したりできるようになります。「非標準的な」カーネルを許容できる特殊な環境のためのオプションです。ブートさえできないようなカーネルを作ってしまいがちですので、上級者でない方は触らないほうがいいでしょう。

このオプション自体は他の選択肢を提供するだけで、実質的な効果はありません。

== MODULES ==

モジュールサポートを有効にします。

カーネルモジュールは実行中のカーネルに読み込めるコンパイル済みのコードの塊です。このオプションをONにしておくとカーネルの部分部分をモジュールとしてビルドできるようになります（yesの代わりにMを指定する）。ブート時に必要ない、あまり使用しない機能のためによく使われます。詳しくは{{Link|LKN/Chapter4}}および''modprobe''、''lsmod''、''modinfo''、''insmod''、''rmmod''のmanpageを参照して下さい。

yesにしておくと、後に''make modules_install''を実行してモジュールをインストール（''/lib/modules''配下に配置）する必要があります。

== IOSCHED_NOOP ==

No-op I/Oスケジューラを使います。

No-op I/Oスケジューラは、最小限のマージとソートしかしないミニマルなスケジューラです。主にメモリデバイスなど、ディスクベースでないブロックデバイスや、その他の特殊なハードウェア/ソフトウェア環境で、独自のスケジューリングを実行するためカーネルからの手助けがあまり必要ないときに使用されます。

== IOSCHED_AS ==

Anticipatory I/Oスケジューラを使います。

Anticipatory I/Oスケジューラはデフォルトのディスクスケジューラです。大半の環境ではこれが適していますが、後述のDeadlineスケジューラと比べるとかなり大規模で複雑です。またデータベースを使用する際などはパフォーマンスもあまり優れません。

== IOSCHED_DEADLINE ==

Deadline I/Oスケジューラを使います。

Deadline I/Oスケジューラはシンプルでコンパクトな構成になっています。大抵の場合、Anticipatoryスケジューラと同等に良い仕事をしてくれますし、データベースを使用する際などはこちらのほうが優れています。シングルプロセスでのI/OではAnticipatoryとほぼ同じ動作をするので、これも良い選択肢です。

== IOSCHED_CFQ ==

CFQ I/Oスケジューラを使います。

CFQ I/Oスケジューラは各プロセスに均等に帯域幅を分け与えようとします。主にデスクトップ向けにそれなりの環境を提供してくれます。

== SMP ==

対称型マルチプロセッシング。

このオプションでマルチCPUを有効にできます。マシンにCPUが一台だけなら、noを選びます。複数のCPUが搭載されているならyesです。

noを選ぶと、シングルプロセッサのマシンでもマルチプロセッサのマシンでもカーネルは動作しますが、使うCPUは1つだけになります。yesを選んでも、大体のシングルプロセッサマシンでカーネルは動作しますが、動作しないこともあります。シングルプロセッサマシンではnoにしておいたほうが高速に動作します。

注意すべきは、yesを選んだ上でプロセッサファミリーとして586またはPentiumを選択すると、486アーキテクチャでは動作しない点です。また、PProアーキテクチャ用のマルチプロセッサカーネルもPentiumベースのボードでは一部動作しない場合があります。

''Documentation/smp.txt''、''Documentation/i386/IO-APIC.txt''、''Documentation/nmi_watchdog.txt''、および''http://www.tldp.org/docs.html#howto''も参照して下さい。

== M386 ==

最適化のためにCPUの種類を選択します。全てのx86 CPUで動作する（が、最速ではない）カーネルにするには386を選択しておきます。

選択したものより古いアーキテクチャでは必ずしも動作するとは限りません。例えばPentiumに最適化されたカーネルはPProでは動作しますが、i486では動作しないかも知れません。

高速化のために推奨の設定は以下のとおりです。

;386
:  AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI 486DLC/DLC2, UMC 486SX-SあるいはNexGenNx586プロセッサ向け。386クラスのマシンでは386カーネルしか動作しません。
;486
:  AMD/Cyrix/IBM/Intel 486DX/DX2/DX4、SL/SLC/SLC2/SLC3/SX/SX2、UMC U5DあるいはU5S向け。
;Pentium-Classic
:  Intel Pentium向け。
;Pentium-MMX
:  Intel Pentium MMX向け。
;Pentium-Pro
:  Intel Pentium Pro向け。
;Pentium-II
:  Intel Pentium IIかCoppermine以前のCeleron向け。
;Pentium-III
:  Intel Pentium IIIかCoppermine Celeron向け。
;Pentium-4
:  Intel Pentium 4かP4ベースのCeleron向け。
;K6
:  AMD K6、K6-II、K6-III（別名K6-3D）向け。
;Athlon
:  AMD K7ファミリー（Athlon/Duron/Thunderbird）向け。
;Crusoe
:  Transmeta Crusoe向け。
;Efficeon
:  Transmeta Efficeon向け。
;Winchip-C6
:  元祖IDT Winchip向け。
;Winchip-2
:  IDT Winchip 2向け。
;Winchip-3
:  3DNow!機能付きのIDT Winchip向け。
;GeodeGX1
:  Geode GX1 (Cyrix MediaGX)向け。
;Geode GX/LX
:  AMD Geode GXあるいはLX向け。
;CyrixIII/VIA C3
:  VIA Cyrix III あるは VIA C3向け。
;VIA C3-2
:  VIA C3-2 "Nehemian" （モデル9以上）向け。
よく分からない場合は386でOKです。

== X86_GENERIC ==

選択したx86変種用の最適化に加え、一般的な最適化を行います。選択しておくと選択したものでないx86 CPUにおいてパフォーマンスが向上します。ディストリビューションなどの配布者向けのオプションです。

== NR_CPUS ==

CPU数の上限。

このカーネルがサポートするCPU数の上限を指定できます。最大は255で最小は2です。

CPUをひとつ多くサポートするたびにカーネルイメージを8KB消費するので、メモリ節約のためのオプションです。

== SCHED_SMT ==

SMT (HyperThreading) スケジューラ。

SMTスケジューラを使うとHyperThreading搭載Intel Pentium 4のスケジューリングを改善しますが、そこかしこでオーバーヘッドが増加します。

== PREEMPT_NONE ==

強制プリエンプションなし（サーバ向け）。

従来のプリエンプションモデルで、スループットの最大化を狙ったものです。あまり遅延が問題になることはありませんが、たまに大きな遅延が発生します。

サーバや科学計算のためのシステムならこれがお勧めです。

== PREEMPT_VOLUNTARY ==

ボランタリ・プリエンプション（デスクトップ向け）。

カーネルのコードに明示的プリエンプションを追加することでカーネルのレイテンシを低減することを狙ったものです。多少スループットを犠牲にしてアプリケーションのレスポンスを向上させます。

このオプションが有効だと、優先度の低いプロセスは、たとえカーネルモードでシステムコールを実行していても自発的にプリエンプションを行えるようになります。これによって見かけ上のレスポンスが良くなります。

デスクトップシステムならこれがお勧めです。

== PREEMPT ==

プリエンプション可能なカーネル（デスクトップ向け）。

カーネル内のほぼ全てのコードをプリエンプション可能にすることでカーネルのレイテンシを低減します。このオプションが有効だと、優先度の低いプロセスは、たとえカーネルモードでシステムコールを実行していても自発的にプリエンプションを行えるようになります。これによって見かけ上のレスポンスがよくなります。多少スループットを犠牲にし、カーネルにランタイムオーバーヘッドが加わります。

デスクトップか組み込みシステムで、レイテンシの要求がミリ秒単位の場合はこれがお勧めです。

== PREEMPT_BKL ==

Big Kernel Lockプリエンプションを有効にしてレイテンシを低減します。

デスクトップならONがいいでしょう。

== NOHIGHMEM ==

Linuxはx86システムでは64GBまでメモリを使用できますが、32-bit x86プロセッサのアドレス空間は4GBしかありません。つまり、大容量の物理メモリがあっても全部をカーネルが使うことはできないということです。こうして恒常的にマップされない物理メモリをHigh memoryと呼びます。

1GBを超えるメモリを積んだマシンでは動かさないと分かっているならoffで構いません（デフォルトで、普通はこれで大丈夫です）。すると、メモリは3GB/1GBに分かれます。各プロセスからは3GBの仮想メモリ空間が見えて、仮想メモリ4GBのうちの残りをカーネルができるだけ物理メモリにマッピングします。

マシンに1〜4GBの物理メモリを搭載しているなら4GBを選びます。

マシンに搭載しているメモリが4GBを超える場合、64GBを選びます。するとPAE (Physical Address Extension) モードが有効になります。PAEはIA32プロセッサで3レベルページングを実装しています。PAEはLinuxで完全にサポートされており、PAEモードはPentium Pro以降のIntelプロセッサなら利用可能です。

{{LKN/Tip| 64GBを選ばないと、PAE非対応のCPUでは起動しません。}}

物理メモリの実際の容量は自動検出できますし、コマンドラインオプション''mem=256M''などでして出来ます（コマンドラインオプションについては{{Link|LKN/Chapter9}}を参照）。

よく分からない場合はoffで大丈夫です。

== HIGHMEM4G ==

32bitプロセッサで1〜4GBの物理メモリを搭載している場合は選択します。

== HIGHMEM64G ==

32bitプロセッサで4GB以上の物理メモリを搭載している場合は選択します。

== FLATMEM_MANUAL ==

Linuxによるメモリ管理の方法を変更できます。普通、ここではFLATMEMしか選択できないはずです。これは正常で、正しいオプションです。

NUMAやメモリホットプラグなどを使用するユーザは別のオプションが選べるでしょう。DISCONTIGMEMは成熟した、よくテストされたシステムですが、メモリホットプラグとは互換性がありませんし、SPARSEMEMと比べるとパフォーマンス面で劣ります。SparseとDiscontiguousメモリのどちらかよく分からない場合はdiscontiguousを選びましょう。

よく分からない場合はこれを選択しておきます。

== DISCONTIGMEM_MANUAL ==

Discontiguousなメモリシステムの場合はFLATよりもこちらのほうが適しています。これらのシステムでは物理アドレス空間に穴があり、こちらのほうがこれらの穴をより効率的に扱えるからです。ただし、大多数のシステムはかなりフラットなアドレス空間を持っており、このオプションのオーバーヘッドによってパフォーマンスが低下することもよくあります。

NUMAの場合はこれしか選択肢がないことが多いです。

よく分からない場合はFLATを選択しておきましょう。

== SPARSEMEM_MANUAL ==

メモリホットプラグなどのシステムではこれしか選択肢がないと思います。

その他のシステムではDiscontiguousの代替として選択できます。こちらのほうがパフォーマンスが高く、コードもシンプルですが、新しくて実験的です。

よく分からない場合はDISCONTIGかFLATを選択しておきましょう。

== SECCOMP ==

信頼できないバイトコードを計算するアプリケーションを利用する際に便利なオプションです。Seccompではパイプなどを使ってこれらのアプリケーションを独自のメモリ空間に隔離することができます。''/proc/pid/seccomp''でseccompを有効にすると無効にすることは出来ず、タスクはseccompモードに従ってごく一部のシステムコールしか実行できなくなります。

よく分からない場合はyesにしておきましょう。組込みシステムではnoが適しています。

== KEXEC ==

kexecは実行中のカーネルをシャットダウンして別のカーネルを起動する実験的なシステムコールです。リブートと似ていますが、ファームウェアに依存しません。また、リブートと同様、Linuxに限らずどんなカーネルでも起動できます。

kexecという名前はexecシステムコールに似ているところに由来します。

この機能はもしかすると正常に動作しないかも知れません。その場合、デバイスホットプラグを有効にしてみてください。執筆時点ではハードウェアインタフェースが非常に流動的なのでなにもおすすめすることはできません。

== HOTPLUG_CPU ==

yesにするとCPUのon/offができるようになり、SMPシステムでサスペンドが利用できます。CPUは''/sys/devices/system/cpu''インタフェースで操作できます。

== PM ==

電源管理。

PMを有効にするとマシンの一部をシャットオフしたり節電スリープモードに落とすことができます。これには2つの競合する標準が存在します。APMとACPIです。このどちらかを使いたい場合はyesにしておきます。

電源管理は主にラップトップで重要になります。ラップトップをお持ちなら、Linux Laptopホームページ(http://www.linux-on-laptops.com)、Tuxmobil-Linux on Mobile Computers (http://tuxmobil.org)、およびBattery Powered Linux (http://www.tldp.org/docs.html#howto) も参考にして下さい。

たとえここでnoを選択してもx86アーキテクチャならシステムがアイドルであるときはHLT命令を出してプロセッサをスリープに落とします。

== SOFTWARE_SUSPEND ==

サスペンドを有効にします。

サスペンドすると、イメージがスワップ領域に保存されます。次回ブート時に''resume=/dev/swappartition''パラメータを指定するとそのイメージを使ってメモリの状態をリストアし、レジュームすることができます。サスペンドしたがレジュームしたくない場合は''noresume''パラメータを指定します。ただし、パーティションはfsckされるのでmkswapを実行する必要があります。

今回だけレジュームせずにブートし、次回にレジュームすることもできますが、その間にはサスペンドに塩湯したスワップパーティションやスワップファイルは使用不可になります。この場合も、ディスク上のバッファが保存したものと一致しなくなるリスクがあります。

より詳しくは''Documentation/power/swusp.txt''を参照して下さい。


== ACPI ==

ACPI (Advanced Configuration and Power Interface)サポートを有効にします。ACPIを使うには対応したハードウェアとファームウェア、およびOSPMソフトウェアが必要です。これでカーネルのサイズが約70KBほど増大します。

LinuxのACPIは、従来のコンフィグ・電源管理インタフェースの代替としてロバストで高機能な
ものとなっています。従来のとは、たとえばPnP BIOS、MPS、APMなどです。もしACPIとAPMが両方有効になっていれば、先にロードされたほうが使われます。

ACPIのSourceForgeプロジェクトページ http://sourceforge.net/projects/acpi にて最新のソースコード、ドキュメンテーション、ツール、メーリングリスト他のリソースが手に入ります。

LinuxのACPIはIntel社のACPI Component Architectureに従っています。詳しくは http://developer.intel.com/technology/iapc/acpi を参照して下さい。

ACPIはオープンな仕様で、Compaq、Intel、Microsoft、PhoenixおよびToshibaによって策定されました。仕様は http://www.acpi.info で公開されています。

== CPU_FREQ ==

CPU周波数スケーリングを使うとCPUのクロックをオンザフライで変更できます。CPUクロックが低いほど消費電力も少なくなるので、節電の効果があります。

これだけでは自動的にCPUクロックを変更してはくれません。後述する動的なCPUFreqポリシーガバナーを使うか、別のユーザスペースツールを使う必要があります。

詳しくは''Documentation/cpu-freq''を参照して下さい。

== CPU_FREQ_DEFAULT_GOV_PERFORMANCE ==

CPUFreqのパフォーマンス重視型ガバナーを使います。つまりCPUの対応する最高周波数を常に使います。

== CPU_FREQ_DEFAULT_GOV_USERSPACE ==

CPUFreqのユーザスペースガバナーを使います。これを使うと周波数を手動で、あるいはユーザスペースプログラムを使って動的に設定することができます。

== CPU_FREQ_GOV_PERFORMANCE ==

このガバナーはCPU周波数を常に最高に設定します。

== CPU_FREQ_GOV_POWERSAVE ==

このガバナーはCPU周波数を常に最低に設定します。

== CPU_FREQ_GOV_USERSPACE ==

このガバナーでは周波数を手動で、あるいはユーザスペースプログラムを使って動的に設定できます。

== CPU_FREQ_GOV_ONDEMAND ==

この動的なガバナーはCPUをポーリングし、仕様状況に応じて周波数を変更します。このガバナーが使えるかどうかは、CPUが高速周波数切替（低遅延での周波数切替）に対応しているかによります。

== CPU_FREQ_GOV_CONSERVATIVE ==

このガバナーは目的もソースコードもOndemandに似ていますが、バッテリーで動作するシステムに最適化されている点が違います。周波数は急に100に飛んだりせず、緩やかに上昇・下降します。

ラップトップ、PDA、あるいはAMD64ベースのマシンを使うなら、周波数切替のレイテンシの問題がありますので、このガバナーをお勧めします。デスクトップならばOndemandガバナーのほうが適しているでしょう。

== PCI ==

PCIは内部デバイスや追加デバイスがプロセッサとやりとりするためのバスシステムです。非常に一般的で、ほとんどのマシンに搭載されています。

特に理由がない限りyesで大丈夫です。

== PCCARD ==

PCMCIA/PCカードを使いたいならyesにします。これらはクレジットカード大のデバイスで、主にモデムやネットワークカード、ハードディスクなどに使われます。

その内訳は2種類あります。16bitのPCMCIAと32bitのCardBusです。

== PCMCIA ==

16bitのPCMCIAカードをサポートします。古いPCカードはだいたいが16bitのPCMCIAなので、32bitのCardBusしか使わないと分かりきっているとき以外はyesにしておきましょう。

通常、カードにともなってソフトウェアが必要になります。詳しくは''Documentation/Changes''を参照して下さい。

== CARDBUS ==

CardBusは32bit対応のPCカードです。最近のPCカードにはCardBusのものが増えてきました。

32bitのPCカードを使うにはCardBus互換のホストブリッジが必要です。ほぼすべてのPCMCIAブリッジが対応していますし、"yenta互換"でもありますので、そのオプションも有効化します。

== NET ==

ネットワーキング。

特殊な理由がないかぎりyesにしておきましょう。これは、スタンドアローンマシンを作るにしても、一部のプログラムはネットワーキングサポートがないと動作しないからです。

古いカーネルからアップグレードするならネットワーキングツールもアップグレードしたほうがいいかもしれません。これらは''net-tools''パッケージに含まれます（具体的には''Documentation/Changes''を参照して下さい）。

Linuxネットワーキングの基礎についてはNET-HOWTO (http://www.tldp.org/docs.html#howto) を一読することを強くお勧めします。

== UNIX ==

Unixソケット。

yesにするとUnixソケットが使えます。Unixソケットはネットワーク接続するための標準的なメカニズムです。X Window Systemをはじめとしsyslog、udevなどの基本的なプログラムがUnixソケットを利用しますので、スタンドアローンマシンを作るにしても、yesにしておくことを強くお勧めします。

== INET ==

TCP/IPネットワーク。

インターネットおよびほとんどのローカルEthernetで使われるプロトコルです。X Window Systemなどはこれに依存しますので、スタンドアローンマシンを作るにしても有効にしておいたほうがいいでしょう。これによってカーネルのサイズが114KBほど増大します。

Linuxネットワーキングの基礎についてはNET-HOWTO (http://www.tldp.org/docs.html#howto) を一読することを強くお勧めします。

== IP_ADVANCED_ROUTER ==

Linuxマシンをルータ（ネットワークパケットを転送する役割）として利用したいならyesにします。yesにするとさらに細かいオプションが指定できます。

このオプション自体は他の選択肢を提供するだけで、実質的な効果はありません。

ルータとして使うにはIPフォワードを有効にしておく必要があります。そのためには
 $ echo "1" > /proc/sys/net/ipv4/ip_forward
を実行します。

IPフォワードを有効にするとrp_filterも有効になります。これはパケットのソースアドレスがネットワークインターフェースと食い違っている場合にパケットを拒否する機能で、IPスプーフィング対策になります。セキュリティ上の便益がありますが、非対称ルーティング（ローカルからホスト行きのパケットが、ホストからローカル行きのパケットと別のルートをたどる）をする場合や、IPアドレスを複数持つルータでないマシンとして動作させる場合は問題に成ることがあります。rp_filterをオフにするには
 $ echo 0 > /proc/sys/net/ipv4/conf/device/rp_filter
あるいは
 $ echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
を実行します。

== NETFILTER ==

パケットフィルタリング。

NetfilterはLinuxマシンを通過するネットワークパケットをフィルタしたり書き換えたりするフレームワークです。

Netfilterの最も一般的な利用法は、Linuxマシンを、ローカルネットワークをインターネットから保護するファイアウォールとして使う場合です。Netfilterで利用できるファイアウォール機能はパケットフィルタと呼ばれ、個々のネットワークパケットを種類、ソース、宛先などでフィルタすることができます。

もうひとつの種類はプロキシベースと呼ばれ、よりセキュアですがセットアップが面倒です。このタイプのものはネットワークのトラフィックをより厳重に監視し、手を加えます。また、上位プロトコルについても関知するのが特徴です。さらに、プロキシベースのファイアウォールはローカルクライアントで動作するプログラム自体に変更を加える必要があることが多くなっています。プロキシベースのファイアウォールはカーネルサポートを必要としませんが、通常はパケットフィルタと共に利用されるため、ここではyesを選んたほうがいいでしょう。

また、LinuxマシンをゲートウェイとしてローカルのPCをインターネットに接続させる場合も、yesを選びます。これはIPマスカレードと呼ばれます。ローカルネットワーク上のマシンが外部に何かを送信したい場合、Linuxマシンがそのマシンのふり（マスカレード）をして、つまりローカルマシンからのパケットを書き換えて送信します。また、復路でもこの動きをします。つまり、外部のホストが返事をしたとき、パケットを書き換えてローカルのマシンに転送するのです。こうしてローカルネットワークのマシンは外部からは全く見えないのに、外のホストと通信することができます。また、ポートフォワーディングという機能を使えばローカルネットワーク内で外部アクセスを受け入れるサーバを動かすこともできます。マスカレードはNAT (Network Address Translation)、あるいはPAT (Port Address Translation) とも呼ばれます。

Netfilterのもう一つの使い方はプロキシです。ローカルネットワークのマシンが外部に接続する際、透過的に別のサーバ（キャッシュプロキシサーバなど）に転送できます。

さらにもう一つの使い方は、ブリッジファイアウォールの構築です。パケットフィルタリングとブリッジを同時に利用するとiptablesはブリッジされたトラフィックを見ることができます。Ethernetなど低レベルプロトコルのフィルタリングを行うにはebtablesを使います（ブリッジNetfilter以下のコンフィグオプションです）。

Netfilterの各種モジュールには、従来のipmasqadm、ipchains、プロキシおよびポートフォワーディングに代わるものが存在します。具体的なパッケージについては''Documentation/Changes''のiptablesの項を参照して下さい。

マシンをルータとして使うならyes、そうでなければnoを選びましょう。

== NET_SCHED ==

ネットワークデバイスから複数のパケットを送信する必要があるとき、カーネルはどれを先に送出するか選択せねばなりません。これはキューイングの問題です。いかに「公平に」キューするかについてはいくつかの案が議論されています。

ここでnoを選ぶと、標準的なパケットスケジューラであるFIFO（先着順）スケジューラが使われます。yesを選ぶと、他のアルゴリズムを選択することができ、それぞれのネットワークデバイスに違ったアルゴリズムを割り当てることができます。接続されたネットワークデバイスのいくつかがリアルタイム制約を持つ場合や、最大データフローレートを制限したい場合などに便利です。

スケジューラを管理するには''iproute2+tc''パッケージに含まれるユーザレベルのユーティリティが必要になります（http://linux-net.osdl.org/index.php/Iproute2 から入手）。

QoS (Quality of Service) サポートを有効にすると、diffservとRSVPが使えるようになります。ドキュメンテーションおよびソフトウェアは http://diffserv.sourceforge.net から入手できます。

== IRDA ==

赤外線通信。

IrDAによる赤外線通信を利用したければyesを選びます。IrDAは多くのPDAやラップトップで採用されている近距離無線通信の標準仕様です。

IrDAを使うには''irattach''などのユーザスペースツールも必要になります。詳しくは''Documentation/networking/irda.txt''を参照して下さい。また、http://www.tldp.org/docs.html#howto のIR-HOWTOも読んでみて下さい。

vCardやvCalあどのデータをPDAとやり取りするならOBEXアプリケーションが必要になります。OpenObexは http://sourceforge.net/projects/openobex から入手できます。

== IRLAN ==

IrLANプロトコル。

IrLANプロトコルを使いたければyesを選びます。IrLANは赤外線通信を使ってEthernetをエミュレートする無線LAN通信技術です。

IrLANを使えばHP NetbeamIRや ESI JetEye NETなどの赤外線アクセスポイントを利用できるようになります。また、別のLinuxマシンとアドホックなIrLANネットワークを構成することもできます。

== IRNET ==

IrNETプロトコル。

IrNETプロトコルを使いたければyesを選びます。IrNETはPPPドライバですので、PPP自体も有効にする必要があります。

IrNETはIrDA上でTCP/IP通信を行うもう一つの方法です。IrDAソケット上で同期的PPPを利用します。Linuxマシン同士、またはWindowsマシンとの間で通信できます。

== IRCOMM ==

IrCOMMプロトコル。

IrCOMMプロトコルを使いたければyesを選びます。IrCOMMはシリアルポートをエミュレートし、ttyをしゃべるすべてのアプリケーションを赤外線で利用することができるようになります。PPPやminicomが含まれます。

== IRDA_ULTRA ==

Ultraプロトコル。

UltraIRDAプロトコルを使いたければyesを選びます。時計やビーコンなどのシンプルな機器を使ってIrDAのオーバーヘッドなしに赤外線通信でデータを交換するためのプロトコルです。IrDAのオーバーヘッドとはハンドシェイクや管理フレーム、可変長ヘッダなどに由来するもので、これらがありません。

== BT ==

Bluetooth。

Bluetoothは低価格で低消費電力な短距離無線通信テクノロジーです。IrDAなどの代替として登場しました。半径10mくらいで通信ができます。詳しくは http://www.bluetooth.com を参照して下さい。

LinuxのBluetoothサブシステムは以下のレイヤーから成っています：

;Bluetoothコア
:  HCIデバイスと接続マネージャとスケジューラ
;HCIデバイスドライバ
:  ハードウェアのインタフェース
;SCOモジュール
:  SCOオーディオリンク
;L2CAPモジュール
:  Logical Link ControlとAdaptation Protocol
;RFCOMMモジュール
:  RFCOMMプロトコル
;BNEP
:  Module Bluetooth Network Encapsulation Protocol
;CMTP
:  Module CAPI Message Transport Protocol
;HIDP
:  Module Human Interface Device Protocol

Bluetoothサブシステムを使うにはユーザスペースユーティリティ（''hcifconfig''や''hcid''など）が必要になります。これらはBlueZパッケージで手に入ります（http://www.bluez.org）。

== IEEE80211 ==

ハードウェアに依存しないIEEE 802.11ネットワークスタックを有効にします。

== MTD ==

MTD (Memory Technology Device).

MTDとはフラッシュメモリやRAMなどの機器のことで、組込みシステムでSSDとして動作する類のものです。このオプションはMTDのための汎用サポートを提供します。個別のMTDデバイスのドライバも選択できるようになります。

== PARPORT ==

パラレルポート。

マシンのパラレルポート（25個の穴が並んでいるコネクタ）をプリンタやZIPドライブなどで使用したいならyesを選びます。

詳しくは''Documentation/parport.txt''および''drivers/parport/BUGS-parport''を参照して下さい。パラレルポートに接続できるデバイスについて詳しくは http://www.torque.net/linux-pp.html を参照して下さい。

一つのパラレルポートを複数のデバイスで使うことも可能ですし、ドライバを全てカーネルに組み込んでしまっても大丈夫です。パラレルポートが複数あって、特定のドライバがロード時にどのポートとIRQを使うべきか指定したい場合は、''Documentation/parport.txt''を参照して下さい。

== PNP ==

Plug and Play.

PnPは周辺機器をソフトウェアで設定（IRQの割り当てなど）するための標準仕様です。ジャンパースイッチなどを使わず、BIOS、OS、あるいはユーザスペースのユーティリティで設定ができます。

yesにしておくとPnPが利用できます。また、必要なプロトコル全てをyesにしておきましょう。あるいは、ここはnoにしておき、PnPデバイスは''isapnptools''などのツールを使って設定するという手もあります。

== ISAPNP ==

ISA Plug and Play.

ISA PnPサポートが必要な場合はyesを選びます。詳しくは''Documentation/isapnp.txt''を参照して下さい。

ISA Plug and Playデバイスをお持ちならhttp://www.roestock.demon.co.uk/isapnptoolsで入手できるツールを使って設定することをお勧めします。

== PNPBIOS ==

実験的Plug and Play BIOSサポート。

Linuxではメインボードのリソース（パラレルポートのリソースなど）を自動検出するために「Plug and Play BIOS Specification Version 1.0A May 5, 1994」に則ったPNPBIOSを使用します。これを有効にしたければyesを選択します。またPNPBIOSはメインボードのデバイスとその他のデバイスとで衝突が起こるのを防ぐこともできます。

PNPBIOSはいずれACPIに取って代わられる予定ですが、共存も可能です。あなたのシステムが非ISAでACPI対応ならば、PNPBIOSは不要と思われます。

== IDE ==

ATA/ATAPI/MFM/RLLサポート。

yesを選ぶと、カーネルはATA/(E)IDEやATAPIなどの低価格大容量ストレージを扱えるようになります。最も一般的なのはIDE
ハードディスクとATAPI CD-ROMドライブです。

システムが全てSCSIで構成されているならnoを選んでもかまいません。

* Integrated Disk Electronics (IDE、別名ATA-1）は大容量ストレージの接続のための標準です。1984年にWestern DigitalとCompaqによって策定され、当時はST506という名前でした。
* AT Attachment (ATA)はIDEのスーパーセットに当たるものです。
* Fast-IDEは別名ATA-2あるいはFast ATAとも呼ばれます。
* Enchanced IDE (EIDE)は別名ATA-3です。LBAでいうところの8.4GB以上の大容量ディスクに対応し、4つのディスクやCDROM、テープなどに対応します。
* UDMA/33は別名UltraDMA/33、あるいはATA-4と呼ばれます。高速DMAコントローラを使うことによって高速転送を可能にし、CPU負荷も低減されます。
* ATA Packet Interface (ATAPI) はEIDEのテープ及びCD-ROMドライブで利用されるプロトコルで、SCSIとよく似ています。

SMART IDE (Self-monitoring, -analysis, and -reporting technology) はデータの破損やディスクのクラッシュを防ぐ技術で、ハードウェアの障害の前兆（熱、アクセス時間など）を検出する仕組みです。1995年6月以降のディスクドライブはこの標準に則っているでしょう。カーネル自体はこれには関与しませんが、''smart''などのユーザスペースツールを使えばSMARTの状況を調べられます。

詳しくは''Documentation/ide.txt''を参照して下さい。

== BLK_DEV_IDE ==

拡張IDE/MFM/RLLディスク/CD-ROM/テープ/フロッピーサポート。

yesにしておくと、完全なIDEドライバが利用できるようになり、最大で10のATA/IDEデバイスを使える上、それぞれがマスターとスレーブを持てるので、最大20台のディスクやCD-ROMドライブを利用できるようになります。

詳しくは''Documentation/ide.txt''を参照して下さい。また、ハードディスクについては http://www.tldp.org/docs.html#howto にてDisk-HOWTOおよびMulti- Disk-HOWTOを参照して下さい。

ATA/IDEドライブとインタフェースのパラメータを微調整するには''hdparm''パッケージを使って下さい（ ftp://ibiblio.org/pub/ Linux/system/hardware ）。

rootファイルシステムがIDEにある場合はこのドライバはモジュールではなく組み込みとしてビルドする必要があります。

IDEドライブがない、あるいはメモリの条件が非常に厳しい場合はnoを選ぶといいでしょう。古いハードディスクドライバを選ぶと13KBほど節約できます。それ以外の場合はyesを選びます。

== BLK_DEV_IDEDISK ==

IDE/ATA-2ディスクサポート。

MFM/RLL/IDEの拡張サポートを有効にします。これらのディスクがあり、古いドライバを使う理由が特に無ければyesを選択します。システムがSCSIのみで構成されているならnoで構いません。

rootファイルシステムがIDEディスクにある場合はモジュールではなく組み込みとしてビルドする必要があります。

== BLK_DEV_IDECD ==

IDE/ATAPI CD-ROMサポート。

ATAPI接続のCD-ROMドライブを使用するならyesを選択します。ATAPIはSCSIとよく似たプロトコルで、IDE CD-ROMで利用されます。最近のCD-ROMドライブはほとんどがATAPI接続になっています。

yesにしておくと、ブート時にCD-ROMドライブが検出され、hdbやhdcとして認識されます（''dmesg''コマンドでカーネルのブートメッセージを確認してみましょう）。CD-ROMドライブがこれ一台なら、他のCD-ROMオプションは全てnoにして構いませんが、ISO 9660 CD-ROMファイルシステムのオプションは有効にしておく必要があります。

古いバージョンのLILOはIDE/ATAPI CD-ROMをうまく扱えませんので、http://lilo.go.dyndns.org よりLILO16以降のバージョンを入手して下さい。

== BLK_DEV_IDEFLOPPY ==

ATAPI接続のIDEフロッピードライブを使用するならyesを選びます。

LS-120およびIomega ZIPドライブもこのドライバでサポートされます。ジャンパー設定などに関してはhttp://www.win.tue.nl/~aeb/linux/zip/zip-1.html を参照して下さい。ATAPI PD-CD/CDRドライブはこのドライバではサポートされません。SCSIエミュレーションサポートが必要です。

yesにしておくとフロッピーはブート時に検出され、hdbやhdcとして認識されます（''dmesg''コマンドでカーネルのブートメッセージを確認してみましょう）。

== SCSI ==

SCSIデバイス。

SCSIハードディスク、CD-ROMなどのSCSIデバイスを使用するならyesを選択します。また、SCSIホストアダプタ（SCSIコントローラとも言う）の名前を確認しておきましょう。

また、その他のSCSIプロトコルを使うデバイスがあるときもyesを選びます。例えばIomega ZIPドライブのパラレルポート盤、USBストレージデバイス、Fibre ChannelやFireWireストレージ、IDE-SCSIエミュレーションドライバなどです。

rootファイルシステムがSCSIデバイスにある場合は、モジュールではなく組み込みとしてビルドする必要があります。

== BLK_DEV_SD ==

SCSIディスク。

SCSIハードディスク、FibreChannelディスク、USBストレージあるいはSCSI・パラレル版のIomega ZIPドライブを使用するならyesを選びます。また、http://www.tldp.org/docs.html#howtoのSCSI-HOWTOおよびDisk-HOWTOを参照して下さい。

このオプションはSCSI CD-ROMとは関係ありません。

rootファイルシステムがSCSIデバイスにある場合は、モジュールではなく組み込みとしてビルドする必要があります。

== CHR_DEV_ST ==

SCSIテープサポート。

SCSIテープドライブを使用するならyesを選びます。また、http://www.tldp.org/docs.html#howto のSCSI-HOWTOおよび ''Documentation/scsi/st.txt''を参照して下さい。

このオプションはSCSI CD-ROMとは関係ありません。

== BLK_DEV_SR ==

SCSI CD-ROMサポート。

SCSIあるいはFireWireのCD-ROmドライブを使用するならyesを選びます。また、 http://www.tldp.org/docs.html#howto のSCSI-HOWTOとCDROM-HOWTOを参照して下さい。また、ISO 9660 CD-ROM ファイルシステムサポートも有効にする必要があります。

== CHR_DEV_SG ==

汎用SCSIサポート。

SCSI接続のスキャナやシンセサイザなど、ハードディスク・CD-ROM・テープ以外のデバイスを利用したければ、yesを選択します。カーネル自体はこれらのデバイスを扱えませんので、追加のソフトウェアが必要になるでしょう。

スキャナーに関してはSANE http://www.sane-project.org を、CDライターに関しては Cdrtools http://cdrecord.berlios.de/old/private/cdrecord.html、Disk at Onceに関しては CDRDAO http://cdrdao.sourceforge.net、高音質オーディオCDリーダーのCdparanoiaに関しては http://www.xiph.org/paranoia を参照して下さい。それ以外のデバイスについては自分でドライバソフトウェアを書かないといけないかも知れません。詳しくは''Documentation/scsi/scsi-generic.txt''を参照して下さい。

== CHR_DEV_SCH ==

SCSIメディアチェンジャー。

SCSIメディアチェンジャーのドライバーです。よくあるのはテープライブラリとMOD/CD-ROMジュークボックスです。これは本当のフルなジュークボックス用のオプションで、6枚チェンジャーのような小規模のものには必要ありません。これらは"Type: Medium CHanger"として''/proc/scsi/scsi''にリストアップされています。詳細は''Documentation/scsi/scsi-changer.txt''を参照して下さい。

== SCSI_MULTI_LUN ==

CDジュークボックスのように複数のLUN（Lugical Unit Number）を持つSCSIデバイスを使っているにもかかわらず単一のLUNしか認識されていない場合は、ここでyesを選択することでSCSIドライバに複数のLUNを検出させることができます。複数のLUNを持つデバイスはあたかも複数のSCSIデバイスのように見えます。大半のSCSIデバイスはLUNをひとつしか持ちませんので、普通はnoで大丈夫です。起動/モジュールパラメータの''max_luns''でこの設定をオーバーライドできます。

== SCSI_ATA ==

Seraial ATA (SATA)サポート。

SATAのホストコントローラとデバイスを扱うためのドライバファミリーです。

== MD ==

RAID/LVM。

一つの論理デバイスを通じて複数の物理スピンドルを扱うためのオプションで、RAID・LVMを利用する際に必要です。

== BLK_DEV_MD ==

デバイスマッパ。

デバイスマッパは低レベルなボリュームマネージャです。論理セクタのレンジにマッピングすることができます。色々なマッピングのタイプが選べる上、自分でカスタムのマッピングを含んだモジュールを欠くこともできます。

LVM2などの高レベルボリュームマネージャもこれを利用します。

== IEEE1394 ==

FireWire。

IEEE1394は高パフォーマンスなシリアルバスで、別名FireWireあるいはi.Linkとも呼ばれます。主にデジタルビデオカメラなどのデバイスを接続するのに利用されます。

FireWireハードウェアを使いたい場合はyesを選択します。これはコアサポートのみですので、個別のドライバもインストールする必要があります。

== I2O ==

I2O (Intelligent Input/Output) アーキテクチャを使うとハードウェアドライバを2つに分割できます。OS独自の部分(OSM)とハードウェア独自の部分(HDM)の2つです。OSDは様々なHDMと会話でき、理想としてはHDMはOSに依存しない構成になっています。これによって同じHDMドライバを、関連したOSMさえ存在すれば、複数のOSで利用できることになります。この機能を使うにはI2Oインターフェースアダプターカードがマシンに接続されている必要があります。このカードには特殊なI/Oプロセッサ(IOP)が搭載されており、CPUの代わりにI/Oを受け持つので高速に処理が可能です。

yesにしておくとインターフェースアダプタのドライバとOSMの選択肢が提示されますので、適切なものを選んで下さい。

== NETDEVICES ==

ネットワークデバイス。

他のマシンと接続する事がないのであればnoを選んでも構いません。ネットワークカードを使うならyesを選びます。SLIPやPPPでどこかへ接続する場合もyesを選びます。PLIPによるパラレル接続で他のマシンとやり取りする場合や、AX.25/KISSを利用する場合もyesを選びます。

Tony Bauttsらによる Linux Network Administor's Guide http://www.tldp.org/guides.html も参考にして下さい。

== NET_ETHERNET ==

10M/100Mのイーサネット。

イーサネット(IEEE 802.3あるいはISO8802-2)はもっとも一般的なLANの種類で、大学や企業等でもよく使われています。

よくあるイーサネットの種類は10-base2/Thinnet（同軸ケーブルでチェーン状につなぐ10Mbps接続）、10-BaseT/ツイストペア（ツイストペアケーブルでハブへつなぐ10Mbps接続）、10-BaseF（光ファイバーを使った10Mbps接続）、100-baseTX（二本のツイストペアケーブルを使った100Mbps接続）、100-baseT4（ツイストペアケーブルを四本使った100Mbps接続）、100-baseFX（光ファイバーを使った100Mbps接続）、そしてギガビットイーサネット（光ファイバーかコッパーケーブルを使った1Gbps接続）です。100-base系はFast Ethernetとも呼ばれます。

マシンをイーサネットに接続する予定で、イーサネットのNICを搭載しているなら、yesを選択します。Ethernet-HOWTO http://www.tldp.org/docs.html#howto も参考にして下さい。また、NICごとのドライバも有効にする必要があります。

このオプション自体は他の選択肢を提供するだけで、実質的な効果はありません。

== NET_RADIO ==

無線LAN。

無線LANに関連するオプションですが、アマチュア無線やFMラジオとは関係ありません。

yesを選ぶとWireless Extensionsが有効になり、''/proc/net/wireless''が作成され、''iwconfig''にアクセスできるようになります。Wireless Extensionsは無線LANに関する設定項目や統計情報などをドライバがユーザスペースに提供できるようにするための汎用APIです。Wireless Extensionsに含まれるツールセットだけで全ての種類の無線LANを扱うことができます（ドライバがWireless Extensionsに対応している限り）。もう一つの利点として、OSやドライバを再起動せずにパラメータを変更できる点が挙げられます。

Wireless ExtensionsをPCMCIAで利用したければここでyesを選びます。ツールは http://www.hpl.hp.com/personal/Jean_Tour-rilhes/Linux/Tools.html から入手できます。


== PPP ==

PPPはインターネットのトラフィックを電話線（かシリアル）上で送受信するプロトコルです。利用中のプロバイダがPPPに対応しているか確認しておきましょう。同じ目的で少し古いものにSLIPがありますが、最近のプロバイダならPPPに対応していると思います。

PPPを利用するには''pppd''というプログラムが別途必要です。これについてはPPP-HOWTO http://www.tldp.org/docs.html#howto にて開設されています。''Documentation/Changes''には推奨の''pppd''バージョンが記載されていますので、確認しておきましょう。PPPオプションを有効にするとカーネルのサイズが約16KB増大します。

PPPには実は二種類あり、ひとつは従来の非同期型PPPで、アナログの電話回線を利用します。もうひとつは同期型PPPで、ディジタルなISDNなどの回線を利用します。適切なオプションを選択しましょう。

== PPPOE ==

PPPoEサポートです。このドライバを使うには cvs.samba.org から入手できる最新版の''pppd''が必要です。あるいは、''RoaringPenguin''パッケージ http://www.roaringpenguin.com/pppoe を参照して下さい。

== ISDN ==

ISDN (Integrated Services Digital Networks)は完全にディジタルな電話回線サービスです。多くはSLIPやPPPを用いてインターネットに接続するのに利用されます。通常の電話回線より速度が早く、インターネットを利用中でも通話ができるのが利点です。マシンにISDNカードが搭載されており、プロバイダが対応している場合のみ利用できます。詳しくは  http://www.alumni.caltech.edu/~dank/isdn を参照して下さい。

ISDNを利用したければyesを選びます。

== PHONE ==

Telephony。

Telephonyを使って普通の電話をVoIPに利用したければyesを選びます。

{{LKN/Tip| このオプションはモデムとは関係ありません。}}

== INPUT ==

何らかの入力機器（マウス、キーボード、ペンタブ、ジョイスティックなど）を利用したければyesを選択します。

ヘッドレスな（モニターやキーボードなどが一切ない）マシンを構築する場合はnoで構いません。

詳しくは ''Documentation/input/input.txt''を参照して下さい。

== VT ==

仮想ターミナル。

ディスプレイとキーボードを使ったターミナルを利用したければyesを選びます。仮想というのは、ひとつの物理端末で複数の仮想ターミナルを走らせられるということです。

キーボードとモニタを活用するには少なくともひとつの仮想ターミナルが必要です。したがって、組込みシステム等の場合はnoにしておけばメモリを節約できます。こういったシステムにログインする方法はシリアルかネットワーク接続経由だけになります。

仮想ターミナルは、たとえばひとつのターミナルではシステムの警告メッセージなどを表示しておき、もうひとつではCUIのユーザセッションを走らせ、3つ目でXセッションを動かすなどの使い方ができるので便利です。仮想ターミナルの切り替えは通常、Alt-functionキーなどの組み合わせで行います。

よく分からない場合はyesにしておくのが無難です。

== VT_CONSOLE ==

コンソールは、カーネルのメッセージや警告を受け取り、シングルユーザモードにてログインを受け付けるデバイスです。yesにしておくと仮想ターミナルをコンソールとして利用できます。これはもっとも一般的な利用形態ですので、シリアルだけを使うのでなければyesを選んでおきます。

yesにすると、現在見えている仮想ターミナル(''/dev/tty0'')がデフォルトでシステムコンソールとして利用できます。（これを変更するオプションについては{{Link|LKN/Chapter9}}を参照して下さい。

== SERIAL_8250 ==

標準シリアルポートを有効にするかどうかです。通常はyesを選びます。サーバ専用機にする場合や、シリアルマウスなどでシリアルポートを利用する予定がないときはnoでも構いません。また、CycladesやStallionといったマルチシリアルポートのドライバを使う時もこれは必要ありません。

{{LKN/Tip| 非標準のシリアルポートを使う場合、このドライバをモジュールとしてビルドしてはいけません。アンロード時に設定が失われるからです。この制約は将来、なくなってくれるかもしれません。}}

殆どの場合はyesで大丈夫です。

== AGP ==

AGP (Accelerated Graphics Port)は主にグラフィックカードを接続するのに使われるバスです。

ここでyesを選択するとAGPカードを使えます。いわばマザーボードのチップセット用のAGPドライバとなります。

AGP GARTで提供されるテクスチャメモリ（理論上は256MBまでですが、実際には64か128MB）より多くのテクスチャメモリが必要なら、PCIを使えば数GBまで提供されます。

XとGLXがMTRRサポートでwrite-combiningするにはこの方法しかありません。このオプションを無効にするとOpenGLのレンダリングはかなり遅くなりますが、それでもPIOよりは早いです。

GLXかDRIを使用するならyesを選びます。

== DRM ==

DRI (Direct Rendering Infrastructure) のカーネルレベルでのサポートはXFree86 4.0で登場しました。yesを選ぶと、あなたのグラフィックカードに適したモジュールをリストから選ぶ必要があります。これらのモジュールは同期、セキュリティおよびDMA転送の機能を提供します。詳しくは http://dri.sourceforge.net を参照して下さい。また、AGPも有効にすべきです。

== I2C ==

I2C (I-square-C) はPhilipsによって開発された低速シリアルバスプロトコルで、マイクロコントローラアプリケーションでよく使われます。SMBusはI2Cのサブセットです。詳しくは''Documentation/i2c''、特に''summary''ファイルを参照して下さい。

このオプションでI2CとSMBusの両方に対応できます。ハードウェアセンサーやVideo For Linuxを使うのに必要です。

I2Cに対応させたければ、ここでyesを選んだ上でバスアダプタ固有のドライバを有効にする必要があります。

== SPI ==

SPI (Serial Peripheral Interface)は低レベルな同期的プロトコルです。SPI対応のチップは最大で数十Mbpsの速度でデータを転送できます。チップはコントローラとチップセレクトで特定されます。SPIスレーブの多くは動的に検出できないばかりか、読み込み専用であったり書きこみ専用であったりします。

SPIはマイクロコントローラとセンサー、EEPROMやフラッシュメモリ、コーデックなどのチップ、AD/DAコンバータなどのやり取りによく使われます。MMCやSDカードにも使われ、MMCソケットを利用するDataFlashカードにはSPIが必要です。

SPIはMicrowire、SSP、SSIおよびPSPと同じ4線インターフェース（select, clock, data in, data out）を利用するファミリーに属します。したがってこれらのデバイスにも使えるでしょう。




<references/>


{{Nav
|prev=LKN/Chapter10
|next=LKN/AppendixA
}}
