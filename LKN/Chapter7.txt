<!-- vim: set noexpandtab shiftwidth=4 wrap linebreak filetype=mediawiki: -->
{{#set: title=第7章: カーネルのカスタマイズ}}
{{Nav
|prev=LKN/Chapter6
|next=LKN/Chapter8
}}

= 第7章: カーネルのカスタマイズ =

カーネルをビルドする中で、どのドライバやオプションが必要でどれが不要なのかを判断するのは最も難しい作業の一つです。この章では正しいドライバを見つける手順について説明します。

== ディストリビューションカーネルを使用する ==

どのモジュールが必要かを判断する簡単な方法の一つは、ディストリビューションに付属のカーネルパッケージを調べることです。起動中、動作中のシステムでは既に適切なドライバがハードウェア構成に従って組み込まれているので、判断が楽になります。

カーネルのビルド対象マシンにまだLinuxディストリビューションがインストールされていないなら、LiveCD版を使うのをお勧めします。LiveCD版を起動すればハードウェア構成に合わせたドライバの判別ができます。

=== コンフィギュレーションファイルはどこ？ ===

ほとんどのディストリビューションは、カーネルパッケージにコンフィギュレーションファイルを同梱しています。コンフィグファイルの場所についてはディストリビューションごとのドキュメントを参照してください。通常は''/usr/src/linux/''ディレクトリ配下にあります。

コンフィグファイルが見つからないときは、カーネル自体を見てみてください。ほとんどのディストリビューションカーネルはコンフィグファイルを''/proc''に置くようビルドされています。これを確認するには：

 $ '''ls /proc/config.gz'''
 /proc/config.gz

このファイルが存在するなら、あなたのカーネルソースディレクトリにコピーして展開しましょう。

 $ '''cp /proc/config.gz &tilde;/linux/'''
 $ '''cd &tilde;/linux'''
 $ '''gzip -dv config.gz'''
 config.gz:       74.9% -- replaced with config

このコンフィグファイルを使えばとりあえず正常に動作するカーネルイメージを作ることができますが、欠点として、ソースツリーに存在するほぼ全てのモジュールやドライバをビルドしてしまう点が挙げられます。一台のマシンではそんなに大量のモジュールは必要としません。ですので、不要なオプションをオフにしていくことをお勧めしますが、確実に不要だと分かるものだけオフにしていくよう注意してください。どこかで依存関係があるものをオフにしてしまうと正常に動作しません。


=== 必要なモジュールを判別する ===

ディストリビューションカーネルから取ったコンフィグファイルを使うと、ビルドに大変長い時間がかかります。これは数々のドライバがいちいちビルドされるからです。必要なものだけに絞れば、ビルド時間が大幅に短縮出来るだけでなく、一部の（場合によっては全ての）ドライバをカーネル自体に組み込んでしまうことができ、メモリを節約できたり、アーキテクチャによっては高速に動作するカーネルを作ることができます。ここではどのハードウェアにどのドライバが必要かを判断する2つの例を紹介します。

動作中のシステムでハードウェアにどのドライバが結びついているかを示す場所がいくつかあります。もっとも重要なのは''sysfs''と呼ばれる仮想ファイルシステムです。''sysfs''は常に''/sys''にマウントされています。''sysfs''からはあちこちへシンボリックリンクが張られ、カーネルのどの部分が他の部分とどう結びついているのかを垣間見ることができます。

以降の例には本物の''sysfs''パスやハードウェアの種別が含まれます。あなたのマシンでは別の値になると思いますが、情報が配置されている相対的な場所は同じです。違う値が表示されるからといって慌ててはいけません。

さらに、''sysfs''の内部構造は頻繁に変更されます。これはカーネル開発者がカーネルの内部構造をユーザスペースに提示するベストな方法を模索し、整理や改変を続けるからです。したがってこの章で紹介するいくつかのシンボリックリンクは最新版では亡くなっているかも知れません。ただ、その場合も情報はなくなったわけではなく、別の場所に移動しただけだと覚えておいてください。

==== 例：ネットワークドライバを判別する ====

NIC（ネットワーク・インタフェース・カード）はシステムの中でも最も重要なハードウェアの一つです。ネットワーキングが正常にできるようにするためにはドライバの判別が必須です。

まず、ネットワーク接続名からPCIデバイスを見つけます。そのためにはまずネットワーク接続名をリストします。

 $ '''ls /sys/class/net/'''
 eth0  eth1  eth2  lo

''lo''ディレクトリはループバックデバイスで、実際のネットワークデバイスとは関係ありません。ここでは''eth1''、''eth1''そして''eth2''ディレクトリが実際のネットワークですので、そこに注目します。

さらにどのNICが大事かを判別するには''ifconfig''を使います。

 $ '''/sbin/ifconfig -a'''
 eth0      Link encap:Ethernet  HWaddr 00:12:3F:65:7D:C2
           inet addr:192.168.0.13  Bcast:192.168.0.255  Mask:255.255.255.0
           UP BROADCAST NOTRAILERS RUNNING MULTICAST  MTU:1500  Metric:1
           RX packets:2720792 errors:0 dropped:0 overruns:0 frame:0
           TX packets:1815488 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:100
           RX bytes:3103826486 (2960.0 Mb)  TX bytes:371424066 (354.2 Mb)
           Base address:0xdcc0 Memory:dfee0000-dff00000
 eth1      Link encap:UNSPEC  HWaddr 80-65-00-12-7D-C2-3F-00-00-00-00-00-00-
           00-00-00
           BROADCAST MULTICAST  MTU:1500  Metric:1
           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:1000
           RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
 eth2      Link encap:UNSPEC  HWaddr 00-02-3C-04-11-09-D2-BA-00-00-00-00-00-
           00-00-00
           BROADCAST MULTICAST  MTU:1500  Metric:1
           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:1000
           RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
 lo        Link encap:Local Loopback
           inet addr:127.0.0.1  Mask:255.0.0.0
           UP LOOPBACK RUNNING  MTU:16436  Metric:1
           RX packets:60 errors:0 dropped:0 overruns:0 frame:0
           TX packets:60 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:0
           RX bytes:13409 (13.0 Kb)  TX bytes:13409 (13.0 Kb)

この中で、''eth0''が実際に動作中のNICだと分かります。

 eth0      Link encap:Ethernet  HWaddr 00:12:3F:65:7D:C2
           inet addr:192.168.0.13  Bcast:192.168.0.255  Mask:255.255.255.0

この出力が、''eth0''はイーサネットデバイスで、正常なIPアドレスが割り当てられていることを示しているからです。

さて、このeth0が新しいカーネルでも正常に動作するように、これをコントロールしているドライバを見つけます。そのためには、''sysfs''ファイルシステムにある色々なリンクを次のコマンドで調べます。

 $ '''basename &grave;readlink /sys/class/net/eth0/device/driver/module&grave;'''
 e1000

この結果、<code>e1000</code>というモジュールが''eth0''をコントロールしていることが分かりました。この''basename''コマンドは以下のことをしてくれています：

# シンボリックリンク''/sys/class/net/eth0/device''を辿り、''/sys/device''ツリー内で''eth0''のコントローラについての情報がある場所へ行き着きます。新しいバージョンのカーネルでは''/sys/class/net/eth0''ディレクトリ自体がシンボリックリンクになっているかも知れません。
# ''sysfs''内でデバイスについて説明しているこのディレクトリには、このデバイスのドライバへのシンボリックリンクがあります。そのリンクは''driver''という名前なので、それを辿ります。
# ''sysfs''内でドライバについて説明しているこのディレクトリには、このドライバを含むモジュールへのシンボリックリンクがあります。このリンクは''module''という名前です。'7readlink''コマンドでこのリンクの対象パスを取得します。
# 重要なのはモジュールの名前だけですので、不要なパスを切り捨てます。''basename''はそのためのコマンドです。

というわけで、このワンライナーでリンクをいくつか辿り、basenameを取得したことになります。

これでモジュール名が分かりましたので、該当するカーネルコンフィグオプションを探します。メニューを使って探してもいいですし、カーネルのソースコード自体を検索すれば正しいオプションかどうかを確認できます。

 $ '''cd &tilde;/linux/linux-2.6.17.8'''
 $ '''find -type f -name Makefile | xargs grep e1000'''
 ./drivers/net/Makefile:obj-$(CONFIG_E1000) += e1000/
 ./drivers/net/e1000/Makefile:obj-$(CONFIG_E1000) += e1000.o
 ./drivers/net/e1000/Makefile:e1000-objs := e1000_main.o e1000_hw.o e1000_
 ethtool.o e1000_param.o

'''<code>e1000</code>'''をあなたの目的のモジュール名に変えるのを忘れないで下さい。

<references/>

{{Nav
|prev=LKN/Chapter6
|next=LKN/Chapter8
}}
