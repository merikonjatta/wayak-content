<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第1章: 配列とスカラー}}
{{Nav
|next=PerlHard/Chapter3
}}

= 第1章: 配列とスカラー =
この章では2つのビルトインタイプ、配列とスカラーを紹介する。スカラーは単一の値として扱われる数値や単語などを指す。配列は順序付きの要素の集合で、それぞれの要素はスカラーだ。

また、コマンドライン引数を扱うために基本的な命令や演算子、サブルーチンの定義と呼び出し、パラメータのパース、そしてファイルの読み込みも扱う。章の最後ではこれらの機能を使った簡単なデモプログラムを取り上げる。

さらに、Perlにおいて重要な概念であるコンテキストについても解説する。

== 1.1 Echo ==

UNIXにはechoというユーティリティがある。これはコマンドライン引数をいくつでも受け付け、それらを出力するだけのものである。同じ事をするPerlプログラムは以下のように書ける。
    print @ARGV;
このプログラムにはprint文がひとつだけ書かれている。あらゆる文はセミコロンで終わる。が、あらゆる一般化が実際には嘘であるように、これも実際には嘘である。本書ではこのように、たびたび複雑な実情を無視して、学び始めるのに重要なエッセンスだけを述べる場合がある。重要な実情がある場合は別の機会に述べることにする。

このprint文の非演算子は<code>@ARGV</code>だ。アットマークは、<code>@ARGV</code>が配列変数であることを示している。この配列はビルトインで、中にはプログラム実行時に与えられた引数が全て格納されている。

Perlプログラムを実行する方法は幾つかあるが、最も一般的なのは"shebang"行を冒頭に入れておくやり方だ。この行ではPerlプログラムを解釈して実行する<code>perl</code>というプログラムの場所を指定する。私のシステムでは<code>whereis perl</code>の結果<code>/usr/bin</code>と出力されたので、"shebang"行はこうなる：
    #!/usr/bin/perl
    print @ARGV;
このニ行を<code>echo.pl</code>というファイルに保存する（Perlプログラムファイルには普通.plという拡張子をつける）。これを
    $ chmod +ox echo.pl
というコマンドによって実行権限を与えると、次のようにして実行できる。
    $ ./echo.pl
ここで一度本を置いて、あなたのシステムでPerlプログラムを実行する方法を調べて理解しておこう。

さて、次にこれを試してみる。
    $ ./echo.pl command line arguments
    commandlinearguments$
確かに、コマンドラインの引数が出力された。しかし、単語の間のスペースが無くなっているし、最後に改行が入っていない（プロンプトが同じ行に現れているのはこのためだ）。

この問題はダブルクオート演算子と改行コードで解決できる。
    print "@ARGV\n";

このダブルクオートで囲まれた部分は文字列に見えるかも知れないが、より正確には「評価されると文字列を返す式」だと言える。Perlはダブルクオート式を評価するとき、変数展開とバックスラッシュ展開を行う。

:変数展開
;  ダブルクオートの中に変数名が現れると、その変数の値で置き換えられる。
:バックスラッシュ展開
;  ダブルクオートの中にバックスラッシュで始まるシーケンスが現れると、そのシーケンスに相当する文字列に置き換えられる。

この場合、<code>\n</code>は改行コードに置き換えられたことになる。

このプログラムを実行すると、引数がコマンドラインの通りに出力される。
    $ ./echo.pl command line arguments
    command line arguments 
    $

出力の最後に改行コードが入っているから、プロンプトも次の行に表示されている。だが、なぜ単語の間にスペースが入っているのだろう？その理由は、
    '''変数の評価結果はコンテキスト（文脈）によって変わるから！'''

この場合、変数はダブルクオートの中にあるので、リストコンテキストとして評価される。変数は配列なので、リストコンテキストの中では配列の要素はビルトイン変数<code>$"</code>で繋がれるのだ。この変数のデフォルト値はスペースになっている。


== 1.2 エラー ==

Perlで起こりうるエラーはたった三種類である。

:コンパイルエラー
;  Perlは実行開始前にプログラム全体をコンパイルする。もしシンタックスエラーがあれば、コンパイラーがエラーメッセージを吐き、実行を試みる前に止まる。
:ランタイムエラー
;  コンパイルに成功すると実行が開始されるが、その間に何かおかしいことがあるとランタイムシステムがエラーメッセージを吐き、実行が止まる。
:セマンティックエラー
;  コンパイルに成功し実行もできているが、プログラマーが意図したとおりにならないのがセマンティックエラーだ。もちろん、意図したとおりというのは描いた本人にしか分からない。

<code>print</code>をスペルミスしてみるとコンパイルエラーの例が拝める。実行するとこんなメッセージが表示されるだろう。

    String found where operator expected at ./echo.pl line 3,
    near "prin "@ARGV\n""
     (Do you need to predeclare prin?)
    syntax error at ./echo.pl line 3, near "prin "@ARGV\n""
    Execution of ./echo.pl aborted due to compilation errors.

このメッセージには様々な情報が含まれるが、Perlに慣れ親しんでいないと理解しづらいかも知れない。このように新しい言語を探検するときには、わざとエラーを起こしてよくあるメッセージのパターンを覚えておくと有用だ。

別の例として、変数名をミススペルしてみよう。
    print "@ARG\n";
というプログラムを実行するとこんな出力になる。
    $ ./echo.pl command line arguments

    $
<code>@ARG</code>という変数は無いので、デフォルト値（空のリスト）が使われてしまっている。つまりPerlはほぼ確実にエラーである状況で無理やりプログラムを実行しきったということだ。この挙動は役立つこともあるが、エラーを隠すよりはあらわにして欲しいときもある。そんな時は<code>strict</code>というプラグマを使うといい。

プラグマとは、Perlの挙動をコントロールするモジュールのことだ。<code>strict</code>プラグマを使うには、プログラムに次の行を書き加えるといい。
     use strict;
これで変数名をミススペルしたプログラムを実行すると、こんな出力になる。
     Global symbol "@ARG" requires explicit package name.
これは誤解を招く表現だが、せめて問題を特定するヒントにはなる。


== 1.3 サブルーチン ==

100行を超えるぐらいの規模のプログラムを書いたことがあれば、プログラムを小さなパーツに分けることの重要性は理解されているだろう。だがなぜか多くのPerlプログラマはサブルーチンアレルギーにかかっているようだ。

確かにスタイルというのは個人の嗜好によるところが大きいが、私自身はサブルーチンをよく使う。実際、新しいプログラムを書くときはプログラムと同名のサブルーチンをまず作って、それを呼び出すようにしている。
     sub echo {
        print "@_\n";
     }
     echo @ARGV
このプログラムは先ほどのものと全く同じ動きをするが、コードはより複雑だ。

サブルーチンの宣言は、<code>sub</code>に続いてサブルーチンの名前、そして内容と続く。サブルーチンの内容はヒゲカッコで囲まれた、いくつかの文が集まったブロックだ。ここではブロックに1つだけ文が含まれている。

変数<code>@_</code>はビルトイン変数で、サブルーチンが受け取った引数の配列だ。


== 1.4 ローカル変数 ==

ローカル変数は<code>my</code>キーワードで作成する。次のサブルーチンは<code>params</code>というローカル変数を作って、引数のコピーを代入する。
    sub echo {
        my @params = @_;
        print "@params\n";
    }
<code>my</code>キーワードを書かないと、グローバル変数だと解釈される。<code>strict</code>プラグマを使っているとこれは警告の元になる。エラーメッセージを見てみるために実行してみよう。


== 1.5 配列の要素 ==

配列の要素にアクセスするには、カギカッコ演算子を使う。
    print "$params[0] $params[2]\n";
カッコの中の数字はインデックスだ。この文は<code>@param</code>の<code>0</code>番目と<code>2</code>番目の要素を出力する。ドルマークは、配列の要素がスカラーであることを示している。

スカラーは単一の値をもつシンプルなものであって、要素を複数持つ配列とは異なる。スカラー値には三種類ある。数値、文字列、そして参照である。この場合、配列の要素は文字列だ。

スカラー値を変数に格納するときはスカラー変数を使わなければならない。
    my $word = $params[0];
    print "$word\n";
頭につけたドルマークがスカラーであることを示している。

配列の変数名が<code>@params</code>なので、こんなふうに書きたく成るかも知れない。
    # 間違った書き方
    my $word = @params[0];
一行目はコメントだ。ハッシュマークから行末まではコメントになる。

コメントの言うとおり、二行目は間違っているが、Perlは例によって無理やり実行を試みる。たまたまこのケースでは意図した通りの結果が出てしまうため、エラーに見えないかも知れない。こういった潜在的なエラーを見つけるにはまた別のプラグマを使う。
    use warnings;
するとこんなエラーが出る。
    Scalar value @params[0] better written as $params[0].
Perlを学習するうちは<code>strict</code>と<code>warnings</code>を常に使ってエラーを発見したほうがいいだろう。大規模なプログラムを書くようになってもこれらのプラグマを使って行儀の良いコードを書くよう務めるべきだ。要するに、いつでも使えということだ。

カギカッコの中にインデックスのリストを書くと、配列から一度に複数の値を取得できる。次のプログラムは<code>@words</code>という配列変数を作り、<code>@params</code>の0番目と2番目の要素を格納する。
    my @words = @params[0, 2];
    print "@words\n";
こうして作られた配列をスライスと呼ぶ。


== 1.6 配列とスカラー ==

これまで、Perlの二種類のビルトイン型である配列とスカラーについて見てきた。配列変数は<code>@</code>で始まり、スカラー変数は<code>$</code>で始まる。多くの場合、配列を返す式は<code>@</code>で始まり、スカラーを返す式は<code>$</code>で始まるが、必ずしもそうとは限らない。覚えておくべきは、
    '''式の評価結果はコンテキスト（文脈）によって変わる！'''
点だ。

代入式では、コンテキストは左辺によって決まる。つまり、左辺がスカラーなら右辺はスカラーコンテキストで評価され、左辺が配列なら右辺はリストコンテキストで評価される。

配列がスカラーコンテキストで評価されると、配列の中の要素数が返る。たとえば
    my $word = @params;
    print "$word\n";
というプログラムはパラメータの数を出力する。スカラーをリストコンテキストで評価するとどうなるかは自分で試してみて欲しい。


== 1.7 リストリテラル ==

配列変数に値を代入する方法の一つにリストリテラルがある。リストリテラルは配列を返す式だ。簡単な例として、
    my @list = (1, 2, 3);
    print "@list\n";

殆どの場合、リストと配列は同じものだと思っていい。多少の違いはあるが、現時点で影響のある違いはひとつだけだ。すなわち、リストをスカラーコンテキストで評価すると、要素数ではなく最後の要素が返されるという点だ。

次のプログラムは3と出力する。
    my $scalar = (1, 2, 3);
    print "$scalar\n";
リストを配列変数に代入すると、結果は配列になる。したがって次のプログラムは配列の要素数（これまた3）を出力する。
    my @list = (1, 2, 3);
    my $scalar = @list;
    print "$scalar\n";
微妙な違いである。


== 1.8 リスト代入 ==

代入式の左辺に変数のリストがあると、Perlはリスト代入を実行する。右辺はリストコンテキストで評価され、最初の要素が最初の変数に、二番目の要素が二番目の変数にといった形で代入が起こる。

この機能は、引数リストをローカル変数に代入するときによく使われる。

次のサブルーチンは第一引数を<code>p1</code>、第二引数を<code>p2</code>、残りの引数のリストを<code>@params</code>に代入する。
    sub echo {
        my ($p1, $p2, @params) = @_;
        print "$p1 $p2 @params\n";
    }
<code>print</code>の引数はダブルクオート式なので、変数が展開されて表示される。こういった<code>print</code>文はデバッグの際に便利だ。私はサブルーチンでエラーが発生するとまず引数を<code>print</code>するところからはじめる。


== 1.9 <code>shift</code>演算子 ==

同じ事をするもう一つの方法として（Perlでは同じ事をするのにいっぱいやり方がある）、<code>shift</code>演算子がある。

<code>shfit</code>は引数に配列を取り、2つの操作をする。まず先頭の要素を削除し、それを返す。他の多くの演算子と同様に、<code>shift</code>演算子には副作用（配列の変更）と返り値（操作の結果）が存在する。

次のサブルーチンは先ほどのものと同じ動作をする。
    sub echo {
        my $p1 = shift @_;
        my $p2 = shift @_;
        print "$p1 $p2 @_\n";
    }
<code>shift</code>を引数なしで実行すると、デフォルトで<code>@_</code>が使われる。このような例では引数を省略することが多い。


== 1.10 ファイルハンドル ==

ファイルの内容を読み込むには、まず<code>open</code>演算子でファイルハンドルを得た上で、そのハンドルを使って行を読み込む。

<code>open</code>の非演算子は2つで、ひとつはファイルハンドルにつける任意の名前、もうひとつは開きたいファイルのパスだ。ここでは<code>/user/share/dict/words</code>という、英語の単語を羅列したファイルを開くことにする。
    open FILE, "/usr/share/dict/words";
ここで識別子<code>FILE</code>はグローバルだ。次のようにするとローカル変数に間接ファイルハンドルを取得できる。
    open my $fh, "/usr/share/dict/words";

慣例として、グローバル変数は全て大文字にし、ローカル変数は小文字にする。

いずれにせよ、山括弧演算子を使うとファイルの中の行を読み取ることができる。
    my $first = <FILE>;
    my $first = <$fh>;

より正確には、スカラーコンテキストでは、山括弧で一行を取得できる。リストコンテキストではどうなるか、考えてみて欲しい。

ファイルの最後に到達すると、山括弧演算子は<code>undef</code>を返す。これはPerlにおいて未定義の値を表す値で、ファイルの終端などの特殊な状況で使われる。<code>while</code>ループにおいては<code>undef</code>は偽として扱われるので、山括弧は次のようなループとともに登場することが多い。
    while (my $line = <FILE>) {
        print $line;
    }


== 1.11 <code>cat</code> ==

Unixの<code>cat</code>ユーティリティはファイル名のリストを引数としてそれぞれのファイルの内容を出力する。次のプログラムはそれとほぼ同じ事をする。

    use strict;
    use warnings;
    sub print_file {
        my $file = shift;
        open FILE, $file;
        while (my $line = <FILE>) {
            print $line;
        }
    }
    sub cat {
        while (my $file = shift) {
            print_file $file;
        }
    }
    cat @ARGV;

2つのサブルーチン<code>print_file</code>と<code>cat</code>を作った。最後の行で<code>cat</code>が呼ばれ、コマンドライン引数がサブルーチンの引数となる。

<code>cat</code>サブルーチンは<code>while</code>ループの中で<code>shift</code>をしていて、与えられたファイル名をイテレートする。最終的にリストが空になると<code>shift</code>は<code>undef</code>を返すのでループは終了する。

イテレーションごとに、<code>cat</code>は<code>print_file</code>を呼び出し、<code>print_file</code>はファイルを開いて<code>while</code>ループで内容を出力してゆく。

<code>cat</code>と<code>print_file</code>が両方<code>$file</code>というローカル変数を使っている点に注意しよう。別のサブルーチンの中で登場するのでこれらは衝突することはない。

サブルーチンの定義は呼び出し前に終えている必要がある。このプログラムを打ちこんでみて、サブルーチンの順番を入れ替えてどのようなエラーが出るかを確認してみよう。

== 1.12 <code>foreach</code>と<code>@_</code> ==

前節では、<code>shift</code>演算子と<code>while</code>ループを使って引数リストをイテレートした。これは<code>foreach</code>を使えばより簡潔に書ける。
    # catで使ったループと同じ
    foreach my $file (@_) {
        print_file $file;
    }
<code>foreach</code>文を実行すると、カッコ内の式がリストコンテキストで一度評価される。先頭の要素が名付けた変数（<code>$file</code>）に代入され、ループの本体が実行される。続いてリストの各要素についてループの本体が実行される。

ループ変数を指定しなければ<code>$_</code>が使われる。したがって同じループがこのようにも書ける。
    # the loop from cat
    foreach (@_) {
        print_file $_;
    }
<code>while</code>ループに山括弧演算子を使った時も<code>$_</code>がループ変数になるので、<code>print_file</code>のループはこう書ける。

    # the loop from print_file
    while (<FILE>) {
        print $_;
    }

デフォルトのループ変数<code>$_</code>を使うのには利点と欠点がある。利点は、多くのビルトイン演算子が<code>$_</code>を使うので、書かなくて済むことだ。欠点は、<code>$_</code>はグローバル変数なので、サブルーチンの中で変更するとその影響が他所で現れてしまう点だ。例として、catプログラムの中で<code>$_</code>をこうしてプリントしてみると分かる。
    # the loop from cat
    foreach (@_) {
        print_file $_;
        print $_;
    }
最終的に<code>$_</code>の値は<code>undef</code>になる。ループの終了条件がそれだからだ。

この例ではローカルなループ変数を明示したほうがいいだろう。なぜなら、その変数名がドキュメンテーションとして役立つからだ。<code>cat</code>ではファイルのリストをイテレートしているのが明らかになり、<code>print_file</code>ではファイルの各行をイテレートしているのが明らかになる。書く文字数を減らすとそれだけ意味が伝わりにくくなるのだ。


== 1.13 練習 ==

=== 練習1.1 ===

<code>glob</code>演算子は引数としてパターンを取り、それにマッチするファイルのリストを返す。ディレクトリ内のファイル一覧を取得するのによく使われる。
    my @files = glob "$dir/*";
パターン<code>$dir/*</code>は「<code>$dir</code>という変数が示すディレクトリの中にある全ファイル」を指す。その他のパターンの書き方については<code>glob</code>のドキュメンテーションをみて欲しい。

さて、ディレクトリ名を引数に取り、そこに含まれるファイル名を一行に一つずつプリントするサブルーチン<code>print_dir</code>を作成しよう。

=== 練習1.2 ===

先ほどのサブルーチンを変更し、<code>print_file</code>を使って、ファイル名ではなくファイルの内容を出力するよう書き換えよう。

=== 練習1.3 ===

<code>-d</code>演算子はあるファイルがディレクトリかどうかを判定する。次の例は<code>$file</code>にディレクトリ名が含まれるとき"directory!"と出力する。
    if (-d $file) {
        print "directory!";
    }
<code>cat.pl</code>を書き換え、コマンドライン引数にディレクトリ名が含まれる場合はその中のファイル一覧を出力するよう書き換えよう。




<references/>


{{Nav
|next=PerlHard/Chapter3
}}
