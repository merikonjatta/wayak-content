<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第2章: 正規表現}}
{{Nav
|prev=PerlHard/Chapter1
|next=PerlHard/Chapter3
}}

= 第2章: 正規表現 =

== 2.1 パターンマッチング ==

パターンバインディング演算子<code>=~</code>というものがある。これは左辺の文字列を右辺のパターンと比較し、マッチするときはtrueを返すというものだ。例えば、パターンが文字の羅列なら、左辺にその文字列が含まれるとき、マッチしたことになる。
    if ($line =~ "abc") { print $line; }
手元の辞書ではこのパターンが含まれる単語は"Babcock"だけだが。

右辺には、このような文字列より、マッチパターンを使うことのほうが多い。マッチパターンはこんな見た目をしている：<code>m/abc/</code>。スラッシュの間のパターンには正規表現が使える。つまり、普通の文字に加えて、特殊な意味を持つメタキャラクタが使えるのだ。たとえば<code>.</code>（ドット）というメタキャラクタは、ドットその物ではなく、どんな文字にでもマッチするワイルドカードである。

たとえば<code>pa..u.e</code>という正規表現は、「paに続いて何かの文字が2つあり、次にuがあり、次に何かの文字が1つある」ような文字列にマッチする。私の辞書ではマッチしたのは"departure"、"departures"、"pasture"、"pastures"の4つだった。

次のサブルーチンはパターンとファイル名の2つの引数を取る。ファイルから各行を読み取り、パターンにマッチする行を出力する。こういった小ネタはクロスワードパズルでチートするのに便利だ。
    sub grep_file {
        my $pattern = shift;
        my $file = shift;
        open FILE, $file;
        while (my $line = <FILE>) {
            if ($line =~ m/$pattern/) { print $line }
        }
    }
名前の由来は、同じ目的で用意されているUnixの<code>grep</code>ユーティリティだ。

ついでに、ブロックの最後の文にはセミコロンがいらない事を覚えておこう。

=== 練習2.1 ===

パターンとファイル名のリストを引数として取り、それぞれのファイルの中でパターンにマッチする行を出力するプログラム<code>grep.pl</code>を書いてみよう。ちなみに、Perlにはすでに<code>grep</code>という関数が存在するので、同じ<code>grep</code>という名前のサブルーチンを作るのは良い考えではない。やってみてエラーメッセージを確認しよう。


== 2.2 アンカー ==

クロスワードを解くのに便利なプログラムを作れたが、アンカーを使えばこれを改良できる。アンカーは、ファイルのどの部分に文字列が現れなければいけないかを指定できる。

たとえばクロスワードのヒントが"Grazing place"（放牧する場所）で、既に分かっている文字が"p, ?, ?, ?, u, ?, e"だとしよう。辞書を<code>p...u.e</code>で検索すると57の単語が引っかかる（"Winnipesaukee"なんていうトンデモ単語もある）。

この結果を<code>^</code>メタキャラクタで絞り込める。これは、行頭にパターンがないといけないという意味を持つ。パターンを<code>^p...u.e</code>に変更すると、結果は38件になる（"procurements"や"protuberant"）が含まれる。

さらに<code>$</code>メタキャラクタを使って、パターンが行末で終わらなければいけないことを指定できる。パターンは<code>^p...u.e$</code>となる。これで結果は12件にまで減って、"Grazing place"らしきものはひとつだけになる。他には"perjure"や"profuse"などが含まれるが。

== 2.3 量指定子 ==

量指定子(Quantifier)は、あるシーケンスが何回登場するかを指定するものだ。たとえば<code>{2}</code>という量指定子は、パターンが二度現れる必要があることを示す。だが、量指定子はアトムという「パターンの塊」に適用されるので多少扱いが難しい。

単一の文字はアトムである。カッコで囲まれた文字列もアトムである。したがって<code>ab{2}</code>は"abb"にマッチし、<code>(ba){2}</code>は"baba"にマッチする。<code>(.es.){3}</code>は<code>.es.</code>が三回現れる文字列にマッチする（手元の辞書ではそんなたんごはrestlessnessだけだ）。

<code>?</code>という量指定子はアトムがあってもなくてもいいことを表す。なので<code>(un)?usual</code>というパターンは"usual"にも"unusual"にもマッチする。

同じようにして<code>+</code>という量指定子はアトムが1回以上現れることを示し、<code>*</code>は0回以上現れる事を示す。

ここまで正規表現に関して、パターンマッチングの観点から話をしてきたが、別の見方として、正規表現は文字列の集合を表すとも言える。たとえば<code>abc</code>という正規表現は<code>abc</code>という文字列だけを含んだ集合を表すのだ。また量指定子を使うと大変幅が広がる。<code>a+</code>という正規表現が表す集合には<code>a</code>、<code>aa</code>、<code>aaa</code>、<code>aaaa</code>... が含まれる。無限の要素を持つ集合だ。

<code>a*</code>と<code>a+</code>はほぼ同じ集合を表すが、<code>a*</code>には空文字列が含まれるのが違いだ。

=== 練習2.2 ===

<code>pre</code>で始まって<code>al</code>で終わる文字列(prejudicial, prenatalなど)にマッチする正規表現を書こう。

== 2.4 選択 ==

<code>|</code>（バー）メタキャラクタは"or"のようなもので、その前後のアトムどちらでもよいという事を表す。<code>Nina|Pinta|Santa Maria</code>はNinaかPintaかSanta Mariaにマッチする。

<code>^(un|in)</code>は、unかinで始まる文字列にマッチする。

単一の文字をたくさん<code>|</code>バーでつないで<code>a|b|c|d|e</code>ようにしたい時は、もっと良い書き方がある。これにはカギカッコを使う。カギカッコは、その中のどの文字でもマッチするという、キャラクタクラスを定義する。つまり<code>^[abcde]</code>は、先頭にaかbかcかdかeが来る文字列にマッチするし、<code>^[abcde]+$</code>は最初から最後までa〜eのどれかでできている文字列（accededとか）にマッチする。

関係ないが、どんな五文字の組み合わせがもっとも多くの英単語にマッチするだろう？私の自己ベストは<code>^[eastr]+$</code>の133単語だった。では最も長い英単語にマッチするのは？私の自己ベストは<code>^[nesit]+$</code>の"intensities"だった。

さて、カギカッコの中ではハイフンは文字の範囲を表す。<code>[1-5]</code>は1, 2, 3, 4, 5のいずれかである。<code>[a-emnx-z]</code>は<code>[abcdemnxyz]</code>と等しい。

また、カギカッコの中ではハット<code>^</code>は反転を表す。つまり<code>[^0-9]</code>は数字ではない文字にマッチするし、<code>^[^-]</code>はハイフン以外の文字で始まる文字列にマッチする。

いくつかのキャラクタクラスは定義済みで、<code>\d</code>のようにして使える。<code>\d</code>は数字一文字を表し、<code>[0-9]</code>と同じである。また<code>\s</code>は空白文字（スペース、タブ、改行など）にマッチするし、<code>\w</code>はいわゆる「単語文字」、つまり大文字か小文字のアルファベット、数字、そしてアンダースコア<code>_</code>にマッチする。

=== 練習2.3 ===

* <code>a|b</code>で始まって<code>a|b</code>で終わる単語を全部探してみよう。"adverb"や"balalaika"などが含まれるはずだ。
* aで始まりaで終わる単語と、bで始まりbで終わる単語を探そう。"alfalfa", "bathtub"が含まれるが"absorb"と"bursa"は含まれないはずだ。
* unかinで始まってちょうど17文字の単語を探そう。
* unかinかnonで始まる18文字以上の単語を探そう。


== 2.5 キャプチャ ==

正規表現においてカッコ()は2つの役割を持つ。ひとつは既に学んだように文字の集まりをアトムにまとめ上げて、量指定子などを使えるようにすることだ。もうひとつは、キャプチャグループの指定である。キャプチャとは、あとで使えるように蓄えておくことだ。

たとえばパターン<code>http:(.*)</code>はhttp:で始まる全てのURLにマッチするが、マッチした時、URLの末尾を$1という変数に代入する機能を持つ。次の例ではある行がURLかどうかを確かめ、http:の後ろをプリントする。
    my $pattern = "http:(.*)";
    if ($line =~ m/$pattern/) { print "$1\n" }
FTPのURLも扱いたければこうも書ける。
    my $pattern = "(ftp|http):(.*)";
    if ($line =~ m/$pattern/) { print "$1, $2\n" }
カッコが2つあるので、マッチ時に2つの変数<code>$1</code>と<code>$2</code>が作られる。これらの変数は公報参照と言われ、キャプチャ文字列を格納している。

キャプチャグループは入れ子にすることもできる。例えば<code>((ftp|http):(.*))</code>という正規表現は3つの変数を生成する。<code>$1</code>は最も外側、つまり文字列全体を格納し、<code>$2</code>と<code>$3</code>はその中のそれぞれの文字列を格納する。


== 2.6 最短マッチ ==

このようにして正規表現を書いていくと、いずれちょっと困った仕様に気づく。それは、量指定子は欲張り（greedy）だということだ。<code>http://www.gnu.org/philosophy/free-sw.html</code>のようなURLをパースし、ホスト名<code>www.gnu.org</code>とファイル名<code>philosophy/free-sw.html</code>を分離したいとしよう。次のような正規表現で書けそうだ。
    my $pattern = "(ftp|http)://(.*)/(.*)";
    if ($line =~ m/$pattern/) { print "$1, $2, $3\n" }
だがこれの結果はこうなってしまう。
    http, www.gnu.org/philosophy, free-sw.html
最初の量指定子<code>.*</code>が最長マッチをしてしまったからだ。だからホスト名だけでなくファイル名までマッチしてしまった。我々がしたかったのは最短マッチ、つまり最初にスラッシュがあるまでのマッチだ。

そこで正規表現を<code>(ftp|http)://(.*?)/(.*)</code>と、クエスチョンマークを入れる。これで量指定子*は惨憺マッチするようになる。<code>*?</code>と<code>+?</code>と<code>??</code>は*、+、?と同じだが、最短マッチをする。


== 2.7 違った書き方 ==

正規表現は長くなると読んだりデバッグしたりするのがどんどん辛くなってくる。前述の例ではパターンを変数に割り当て、それを<code>m//</code>の中で使うというやりかたで可読性を高めたが、この方法にも限界がある。

代わりに、正規表現を「拡張」して書くことができる。

    if ($line =~ m{
            (ftp|http) # protocol
            ://
            (.*?) # machine name (minimal)
            /
            (.*) # file name
            }x
       )
    { print "$1, $2, $3\n" }
このパターンは<code>m{</code>で始まり<code>}x</code>で終わっている。xは「拡張」書式であることを示す。この他にも正規表現にはいくつかの修飾子が使える。

残りは普通だが、表現の並べ方は普通でない。最も重要なのは、拡張書式では空白文字とコメントが自由に使え、影響を及ぼさないということだ。


== 2.8 演算子いくつか ==

Perlには演算子が色々と用意されている。これらはCの演算子のスーパーセットと呼べるだろう。+, -, *と/はいつもどおり算術演算に使える。%はモジュラス（剰余）演算子で、**はべき乗を行う。

比較演算子の&gt;, &lt;, ==, &gt;=, &lt;=, ! は数値の比較に使う。文字列の比較にはgt, lt, eq, ge, leそしてneを使う。どちらもPerlは被演算子をまず適切な型に変換するので、例えば<code>10 lt 2</code>とすると、被演算子は数値だが文字列比較を行い、結果はtrueになる。

<code>&lt;=&gt;</code>は「宇宙船」演算子と呼ばれ、左辺が右辺より（数値的に）大きければ1、小さければ-1、等しければ0を返す。

論理演算子は2つが2セットある。&amp;&amp;はandと同じ、||はorと同じだ。いや、同じではないが。記号の方より文字の方が優先度が低い。


== 2.9 前置演算子 ==

既に前置演算子（Prefix operator）はいくつか登場している。<code>print</code>、<code>shift</code>、<code>open</code>などがそれだ。これらは演算子の後ろにコンマ区切りで被演算子を列挙して使う。被演算子はリストコンテキストで評価され、ひとつのリストへflattenされる。

前置演算子は、カッコを使ってCの関数のように使うことができる。次のそれぞれの文は同じ意味だ。
    print $1, $2;
    print($1, $2);
    shift @_;
    shift(@_);
    open FILE, $file;
    open(FILE, $file);
単にカッコはオプショナルだと考えることもできるが、実は挙動にちょっとした違いがある。優先度が変わるのだ。普通あまり影響はないが、たとえばエラーを扱うイディオムとして次のようなものがある。
    open FILE, $file or die "couldn’t open $file\n";
<code>die</code>演算子は被演算子を出力してプログラムを終了する。or演算子はショートサーキット評価を行う。すなわち、左から右へ必要なだけ評価する。

もし<code>open</code>が成功すればそこでtrueが返り、その時点でtrue or xという形をしたこの文はtrueであることが確定するので、dieが実行されることはない。

そこでorと||が等価なら次のように書いてもいいことになる。
    open FILE, $file || die "couldn’t open $file\n";
だが実際には、||はorより優先度が高いので、まずはじめに<code>$file || die "couldn’t open $file\n"</code>が評価され、$fileがtrueであるためそれが返され、dieには絶対に到達しないことになってしまう。

これを避けるためには前述のようにorを使うか、openを関数呼び出し風に記述すればいい。次の例では正しい順番で評価される。
    open(FILE, $file) || die "couldn’t open $file\n";

ついでに、もっと有益なエラーメッセージを表示する方法を紹介しておこう。
    die "$0: Couldn’t open $file: $!\n"
<code>$0</code>には現在実行中のプログラム名が入っており、<code>$!</code>には直近のエラーに関するテキストメッセージが入っている。これは非常によく使うパターンなのでサブルーチンを作っておいてもいいだろう。
    sub croak { die "$0: @_: $!\n" }
croak（ガーガー鳴く）という名前はChristiansen, Wall, Orwant著のProgramming Perlより拝借した。


== 2.10 サブルーチンのセマンティック ==

{{Link|PerlHard/Chapter1}}では、<code>@_</code>はサブルーチン内でパラメータリストを指すと説明したが、より厳密には、このリストの要素は与えられたスカラーへのエイリアスだと言うべきだ。エイリアスとは、変数を指し示すもうひとつの方法だ。言い換えると、<code>@_</code>を使えば引数として与えられた変数にアクセスして書き換えたりできる、ということだ。

例えば、次のswapというサブルーチンは2つの値を取り、それらを入れ替える。
    sub swap {
        ($_[0], $_[1]) = ($_[1], $_[0]);
    }
リスト代入では代入が起こる前に右辺が評価されるので、一時的に値を保持しておく変数を用意する必要がない。

次のコードでswapの挙動をテストできる。
    my $one = 1;
    my $two = 2;
    swap($one, $two);
    print "$one, $two\n",
たしかに、<code>2, 1</code>と出力される。swapは引数を破壊的に変更するので、静的な値を与えると次のようにエラーになる。
    Modification of a read-only value attempted in ./swap.pl
だがこうしてリストで呼び出すことはできる。
    my @list = (1, 2);
    swap(@list);
    print "@list\n";
リストが引数に与えられるとflattenされる。すなわち、要素がそれぞれパラメータリストに追加される。したがって、次のコードでは2つのリストが交換'''されない'''。
    my @list1 = (1, 2);
    my @list2 = (3, 4);
    swap(@list1, @list2);
    print "@list1 @list2\n";
この場合、<code>swap</code>には4つのスカラーが引数として渡るため、最初の2つが交換され、出力は<code>2 1 3 4</code>となる。

== 練習 ==

=== 練習2.4 ===

正規表現では、<code>\1</code>が表現内の最初のキャプチャグループを指し示す。<code>\2</code>は二番目、<code>\3</code>は三番目、以下同様だ。

最初と最後の文字が同じである行にマッチする正規表現を書いてみよう。



<references/>

{{Nav
|prev=PerlHard/Chapter1
|next=PerlHard/Chapter3
}}
