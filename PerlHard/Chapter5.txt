<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第5章: モジュール}}
{{Nav
|prev=PerlHard/Chapter4
|next=PerlHard/Chapter6
}}

= 第5章: モジュール =

この章ではハフマン符号を実装する。それ自体も面白いのだが、Perlの便利な機能を紹介できるだろう。まず最初に、{{Link|PerlHard/Chapter4}}のヒーププログラムをPerlモジュールに仕上げる。次に継承関係にある2つのクラスを作る。最後に、リンクを持ったデータ構造の例として二分木を実装する。

== 5.1 可変長符号化 ==

モールスコードをご存知だろうか。アルファベットをトンとツーで符号化するシステムだ。有名なのは...---... (SOS)だ。他の文字の符号化は次のとおりである。

[[File:perlhard-fig0501.png]]

符号の長さが文字によって異なる点に注意して欲しい。よく使う文字は短い符号で表せるようにデザインされているのだ。短い符号で表せる文字数には限りがあるので、あまり使わない文字は長い符号になるが、平均的なメッセージなら短い符号をよく使うことになるので、全体の長さを短縮できるわけだ。

こういった符号は可変長符号と呼ばれる。この章では別の可変長符号化システムであるハフマン符号を扱う。符号化の方法自体が面白いのだが、さまざまなデータ構造を使って実装することになるので楽しいだろう。

以降の節は次のような構成になっている。
* まず適当な英語のテキストから文字の頻度を測る。
* ハフマン符号の中心部にはハフマン木というものがある。文字の頻度からハフマン木を作る。このハフマン木を用いて文字列をエンコードおよびデコードする。
* 最後にハフマン木を走査してコードテーブルを作成する。

== 5.2 頻度表 ==

よく使う文字には短い符号を与えたいので、文字の登場頻度を測る。Edgar Allen Poeの短編"The Gold Bug"に、登場人物が文字の頻度から暗号を解読するシーンがある。彼いわく、

<blockquote>「英語では、最もよく現れる文字はeだ。そのあとはこんなふうに続く。a o i d h n r s t u y c f g l m w b k p q x zだ。Eはとにかく圧倒的に頻繁にあらわれるから、ある程度の文字の組み合わせでEが一番頻繁じゃないことはほとんどない。」</blockquote
>

というわけで、Poeの説が正しいかどうか検証してみよう。サンプルとして"The Gold Bug"の本文自体を使うことにする（http://gutenberg.net/ からダウンロードできる）。

=== 練習5.1 ===

サンプルテキストにどの文字が何回登場するかを数えるプログラムを書こう。

文字列中の文字を捜査するには、空文字列を分割文字としてsplitすればいい。
    my @list = split "", $line;
    foreach (@list) {
        print "$_\n";
    }

== 5.3 モジュール ==

すでに、use文でモジュールを読み込むコードを紹介した。ここでは新しいモジュールの作り方を解説する。

オブジェクト指向のプログラムにおいて、モジュールとは一般的に、パッケージを定義するファイルのことを言う。{{Link|PerlHard/Chapter4}}のヒーププログラムから、次の手順でモジュールを作成できる。

1. heapl.plをheap.pmというファイル名に変更する。.pmはPerl Moduleだ。
2. テストコードをheap.pmから削る。モジュールをuseすると、Perlはコンパイル時にモジュールを実行する。モジュール内に実行可能なコードを置いてもいいが、普通はサブルーチンや変数の宣言をするだけがよい。
3. ファイルの冒頭のshebang行(#!...)は不要なので削る。
4. モジュールの最後の文はtrueと評価されるべきだ。これはモジュールが正常に実行されたことを意味する。慣例として、最後の文には<code>1;</code>を使う。

=== 練習5.2 ===

heap.plをheap.pmとういモジュールに書き換え、新しいプログラムhuffman.plに<code>use heap;</code>を書き加えよう。実査にプログラムがエラーなく実行できることを確かめよう。

=== 練習5.3 ===

文字とその頻度のペアを表すPairというクラスをつくろう。インスタンス変数letterとfrequencyを持ち、それぞれのアクセサも持つようにしよう。さらに、priorityというメソッドを作り、frequency属性を返すようにしよう。

ここまでできたら、頻度表の文字-頻度ペアを走査してそれぞれのPairオブジェクトを作り、ヒープに追加していく。ヒープからPairをひとつずつremoveして出力してみよう。

Poeの仮説は正しかっただろうか？

== 5.4 ハフマン木 ==

次にハフマン木をつくる。各ノードは文字とその頻度を表し、さらに左と右の子要素を持つ。

ハフマン木を作るにはまず頻度表の各エントリに対応する単一ノードの木を作っていき、それらを下から順に（頻度の低い方から順に）上の木とつないでいく。最終的に全ての文字を含んだ一つの木が構成できるまでこれを繰り返す。

より詳しく言うと、

1. 頻度表の各エントリについて単一ノードのハフマン木を作り、ヒープに追加する。ヒープから要素（木）をremoveすると最も頻度の低い文字が出てくるようにする。

2. ヒープからツリーを2つremoveし、それらを子ノードとする新しい木をつくる。この木のルートノードの頻度は子ノードの頻度を足したものとする。

3. ヒープが空になっていれば終了する。空でなければこの新しい木をヒープに追加し、ステップ2へ戻る。

分かりやすいように例示しよう。簡単のため、ここではadenrstしか含まないサンプルテキストを使う。

<blockquote>Eastern Tennessee anteaters ensnare and eat red ants, detest ant
antennae (a tart taste) and dread Antarean anteater-eaters. Rare
Andean deer eat tender sea reeds, aster seeds and rats’ ears. Dessert?
Rats’ asses.</blockquote>

この奇妙な文章は次のような頻度表になる。
    e  40
    a  32
    t  24
    s  22
    n  20
    r  19
    d  13
したがってステップ1完了後、ヒープはこんなふうになっている。

[[File:perlhard-fig0502.png]]

ステップ2で、最も頻度の低い2つの木（rとd）をremoveし、これらを新しい木につないで頻度を32とする。この木をヒープに追加するとこのようになる。

[[File:perlhard-fig0503.png]]

同じ操作でsとnを組み合わせる。

[[File:perlhard-fig0504.png]]

もう一度繰り返すとこのようになる。ちなみに木の集合は森とも呼ばれる。

[[File:perlhard-fig0505.png]]

あと二回同じ事を繰り返すと木は1つになる。

[[File:perlhard-fig0506.png]]

これでハフマン木は完成だ。もちろん、木を組み合わせるときにどちらが右でどちらが左かは特に意味を持たせず決めたので、同じ頻度を表すハフマン木はこれひとつとは限らないが、今はこれでいい。

さて、ハフマン木から符号表を作成剃る方法だが、それぞれの文字の符号は木の根からその葉までの道のりで決まる。たとえば根からsへの道のりは左・右・左である。左をトン、右をツーで表すことにすると次のような符号表ができあがる。
    e  -.
    a  --
    t  ..-
    s  .-.
    n  .--
    r  ....
    d  ...-
なんとこれで目的は達成されている。頻度の高い文字ほど短い符号で表せた。

=== 練習5.4 ===

次の頻度表のハフマン木を手作業で作ってみよう。
    e  93
    s  71
    r  57
    t  53
    n  49
    i  44
    d  43
    o  37

== 5.5 継承 ==

練習5.3のPairクラスを継承してHuffTreeクラスを作れる。Perlでサブクラスを作るにはクラスに<code>@ISA</code>という配列を定義する。ISAとはis-aのことだ。
    package HuffTree;
    our @ISA = "Pair";

=== 練習5.5 ===

HuffTreeクラスにleftとrightというアクセサメソッドを作ろう。これらのインスタンス変数には他のHuffTreeへの参照が格納されることになる。

HuffTreeクラスはPairクラスからnew, letter, frequencyそしてpriorityを継承する。もちろん別の実装が必要ならオーバーライドすることもできる。この場合、HuffTreeをヒープからremoveする際には頻度の低い方から順に出てきて欲しいので、priorityをこのようにオーバーライドする。
    sub priority {
        my $self = shift;
        return -$self->{frequency};
    }
これで頻度が高いほどpriorityが低くなる。


== 5.6 ハフマン木の構築 ==

頻度表があれば2ステップでハフマン木を構成できる。まずは頻度表を走査して単一ノードの木を作成し、ヒープに追加していく。
    my $heap = Heap->new;
    my $tree;
    while ((my $key, my $value) = each %freqtab) {
        print "$key\t$value\n";
        my $tree = HuffTree->new( letter => $key,
                frequency => $value );
        $heap->add($tree);
    }
次に5.4節で紹介したアルゴリズムに従って木を構築する。
    while (1) {
        my $left = $heap->remove;
        my my $freq = $left->frequency + $right->frequency;
        $tree = HuffTree->new( frequency => $freq );
        $tree->left($left);
        $tree->right($right);
        last if $heap->empty;
        $heap->add($tree);
    }$right = $heap->remove;
葉でないノードについてはfrequencyを保持するがletterは未定義でよい。

ループが終了する時点で木はひとつにまとめられており、$treeはそのルートノードを参照している。

=== 練習5.6 ===

このコードをhufftreeという名前のメソッドにまとめ、%freqtabというパッケージ変数（頻度表）を使ってHuffTreeを構築するようにしよう。また、完成した木を$hufftreeというパッケージ変数に入れよう。


== 5.7 符号表の構築 ==

ある文字の符号はハフマン木の根から葉までの道のりで決まる。文字を符号化するにはツリー全体を走査しなければならないかも知れない。

これはコストが高いので、一度ツリーを走査して表に記録していこう。

木を捜査する際、今までに辿ってきた道のりを記録しておかなければならない。これは難しく思えるかも知れないが、再起を使えば自然な実装が可能だ。なぜならあるノードまでの道のりがトンとツーを組み合わせた文字列pathだとすると、そこから左に行けば新しい道のりは<code>$path."."</code>で、右に行けば<code>$path."-"</code>だからだ。（ドット.演算子は文字列を連結する。）

このアルゴリズムは例えばこのように書ける。
    sub codetab {
        our %codetab;
        my ($tree, $path) = @_;
        if (defined ($tree->letter)) {
            $codetab{$tree->letter} = $path;
            return;
        }
        codetab($tree->left, "$path.");
        codetab($tree->right, "$path-");
    }
letterが定義されていればそのノードは葉であるので、コード表に書きこんで終了する。そうでなければ子要素があるので、再帰する。

最初に呼び出すときは木の根を与え、第二引数は空文字列にすればよい。
    codetab $hufftree, "";

=== 練習5.7 ===

* codetabメソッドを打ち込んで、自分のハフマン木で試してみよう。
* コード表全体を出力するprint_codetabメソッドを実装しよう。よくある文字ほど短い符号になっているだろうか？モールスコードと比べてみよう。どちらのほうが長い符号になっているだろうか？
* 文字列を位置文字ずつcodetabに従って符号化し、結果を返すencodeというメソッドを実装しよう。


== 5.8 デコード ==

ハフマン符号のデコードアルゴリズムは次のようになる。

# ハフマン木の根からスタートする
# 次の符号が-なら左の子ノードへ、.なら右へ行く
# 葉にたどり着いたらその文字を取得し、結果に追記する。根へ戻る。
# ステップ2へ戻る。

<code>..--.--</code>という符号を例に見てみよう。根から左、左、右と移動してtにたどり着く。根に戻り、右、左と移動してeにたどり着く。根に戻り、右、右と移動してaにたどり着く。符号が正しければ、最後に葉にいるはずだ。デコード結果はteaとなる。


=== 練習5.8 ===

例示したHuffTreeを使って次のハフマン符号を解読しよう。

* .-.--.--..---
* .-...--.-......-.
* ...--.-.....
* -.--.-...-

デコードするまで、結果が何文字なのか、区切りはどこなのか判断できない。

=== 練習5.9 ===

* トンとつーから構成された文字列をハフマン木を使ってデコードするdecodeメソッドを実装しよう。
* 文字列をencodeしてからdecodeするテストコードを書こう。

=== 練習5.10 ===

この章で描いた実装は半分オブジェクト指向だ。PairとHuffTreeはオブジェクトだがHuffmanパッケージはただのサブルーチンの集合で、クラスではない。パッケージ変数<code>%freqtab</code>と<code>$hufftree</code>と<code>%codetab</code>を使うので、このパッケージを使うプログラムは一度にひとつのハフマン符号しか扱えない。

より汎用性を持たせるため、これをHuffmanクラスに書き換えよう。<code>$freqtab</code>、<code>$hufftree</code>、<code>$codetab</code>はインスタンス変数にする。この実装では頻度表と符号表はハッシュへの参照にしなければいけない点に注意しよう。

それぞれの実装の利点と欠点はなんだろうか？



<references/>

{{Nav
|prev=PerlHard/Chapter4
|next=PerlHard/Chapter6
}}
