<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第5章: モジュール}}
{{Nav
|prev=PerlHard/Chapter4
|next=PerlHard/Chapter6
}}

= 第5章: モジュール =

この章ではハフマン符号を実装する。それ自体も面白いのだが、Perlの便利な機能を紹介できるだろう。まず最初に、{{Link|PerlHard/Chapter4}}のヒーププログラムをPerlモジュールに仕上げる。次に継承関係にある2つのクラスを作る。最後に、リンクを持ったデータ構造の例として二分木を実装する。

== 5.1 可変長符号化 ==

モールスコードをご存知だろうか。アルファベットをトンとツーで符号化するシステムだ。有名なのは...---... (SOS)だ。他の文字の符号化は次のとおりである。

[[File:perlhard-fig0501.png]]

符号の長さが文字によって異なる点に注意して欲しい。よく使う文字は短い符号で表せるようにデザインされているのだ。短い符号で表せる文字数には限りがあるので、あまり使わない文字は長い符号になるが、平均的なメッセージなら短い符号をよく使うことになるので、全体の長さを短縮できるわけだ。

こういった符号は可変長符号と呼ばれる。この章では別の可変長符号化システムであるハフマン符号を扱う。符号化の方法自体が面白いのだが、さまざまなデータ構造を使って実装することになるので楽しいだろう。

以降の節は次のような構成になっている。
* まず適当な英語のテキストから文字の頻度を測る。
* ハフマン符号の中心部にはハフマン木というものがある。文字の頻度からハフマン木を作る。このハフマン木を用いて文字列をエンコードおよびデコードする。
* 最後にハフマン木を走査してコードテーブルを作成する。

== 5.2 頻度表 ==

よく使う文字には短い符号を与えたいので、文字の登場頻度を測る。Edgar Allen Poeの短編"The Gold Bug"に、登場人物が文字の頻度から暗号を解読するシーンがある。彼いわく、

<blockquote>「英語では、最もよく現れる文字はeだ。そのあとはこんなふうに続く。a o i d h n r s t u y c f g l m w b k p q x zだ。Eはとにかく圧倒的に頻繁にあらわれるから、ある程度の文字の組み合わせでEが一番頻繁じゃないことはほとんどない。」</blockquote
>

というわけで、Poeの説が正しいかどうか検証してみよう。サンプルとして"The Gold Bug"の本文自体を使うことにする（http://gutenberg.net/ からダウンロードできる）。

=== 練習5.1 ===

サンプルテキストにどの文字が何回登場するかを数えるプログラムを書こう。

文字列中の文字を捜査するには、空文字列を分割文字としてsplitすればいい。
    my @list = split "", $line;
    foreach (@list) {
        print "$_\n";
    }

== 5.3 モジュール ==

すでに、use文でモジュールを読み込むコードを紹介した。ここでは新しいモジュールの作り方を解説する。

オブジェクト指向のプログラムにおいて、モジュールとは一般的に、パッケージを定義するファイルのことを言う。{{Link|PerlHard/Chapter4}}のヒーププログラムから、次の手順でモジュールを作成できる。

1. heapl.plをheap.pmというファイル名に変更する。.pmはPerl Moduleだ。
2. テストコードをheap.pmから削る。モジュールをuseすると、Perlはコンパイル時にモジュールを実行する。モジュール内に実行可能なコードを置いてもいいが、普通はサブルーチンや変数の宣言をするだけがよい。
3. ファイルの冒頭のshebang行(#!...)は不要なので削る。
4. モジュールの最後の文はtrueと評価されるべきだ。これはモジュールが正常に実行されたことを意味する。慣例として、最後の文には<code>1;</code>を使う。

=== 練習5.2 ===

heap.plをheap.pmとういモジュールに書き換え、新しいプログラムhuffman.plに<code>use heap;</code>を書き加えよう。実査にプログラムがエラーなく実行できることを確かめよう。

=== 練習5.3 ===

文字とその頻度のペアを表すPairというクラスをつくろう。インスタンス変数letterとfrequencyを持ち、それぞれのアクセサも持つようにしよう。さらに、priorityというメソッドを作り、frequency属性を返すようにしよう。

ここまでできたら、頻度表の文字-頻度ペアを走査してそれぞれのPairオブジェクトを作り、ヒープに追加していく。ヒープからPairをひとつずつremoveして出力してみよう。

Poeの仮説は正しかっただろうか？

== 5.4 ハフマン木 ==

次にハフマン木をつくる。各ノードは文字とその頻度を表し、さらに左と右の子要素を持つ。

ハフマン木を作るにはまず頻度表の各エントリに対応する単一ノードの木を作っていき、それらを下から順に（頻度の低い方から順に）上の木とつないでいく。最終的に全ての文字を含んだ一つの木が構成できるまでこれを繰り返す。

より詳しく言うと、

1. 頻度表の各エントリについて単一ノードのハフマン木を作り、ヒープに追加する。ヒープから要素（木）をremoveすると最も頻度の低い文字が出てくるようにする。
2. ヒープからツリーを2つremoveし、それらを子ノードとする新しい木をつくる。この木のルートノードの頻度は子ノードの頻度を足したものとする。
3. ヒープが空になっていれば終了する。空でなければこの新しい木をヒープに追加し、ステップ2へ戻る。

分かりやすいように例示しよう。簡単のため、ここではadenrstしか含まないサンプルテキストを使う。

<blockquote>Eastern Tennessee anteaters ensnare and eat red ants, detest ant
antennae (a tart taste) and dread Antarean anteater-eaters. Rare
Andean deer eat tender sea reeds, aster seeds and rats’ ears. Dessert?
Rats’ asses.</blockquote>

この奇妙な文章は次のような頻度表になる。
    e  40
    a  32
    t  24
    s  22
    n  20
    r  19
    d  13
したがってステップ1完了後、ヒープはこんなふうになっている。

[[File:perlhard-fig0502.png]]

ステップ2で、最も頻度の低い2つの木（rとd）をremoveし、これらを新しい木につないで頻度を32とする。この木をヒープに追加するとこのようになる。

[[File:perlhard-fig0503.png]]

同じ操作でsとnを組み合わせる。

[[File:perlhard-fig0504.png]]

もう一度繰り返すとこのようになる。ちなみに木の集合は森とも呼ばれる。

[[File:perlhard-fig0505.png]]

あと二回同じ事を繰り返すと木は1つになる。

[[File:perlhard-fig0506.png]]

これでハフマン木は完成だ。

<references/>

{{Nav
|prev=PerlHard/Chapter4
|next=PerlHard/Chapter6
}}
