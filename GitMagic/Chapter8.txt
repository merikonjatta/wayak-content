<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第8章 大暴露}}
{{Nav
|prev=GitMagic/Chapter7
|next=GitMagic/AppendixA
}}

= 第8章 大暴露 =

ここではgitの内部事情に迫る。あまり詳しくは説明しないので、興味があれば[http://schacon.github.com/git/user-manual.html マニュアル]を見て欲しい。


== 透明性 ==

Gitはどうしてこうも目立たずにいられるのだろう。たまにコミットしたりマージしたりするのを除けば、ほとんど存在を意識しなくて済む。そして必要になったときはとてもありがたいのだ。

他のバージョン管理システムでは常に立入禁止エリアなどが気になる。何らかのファイルのパーミッションが読み取り専用だったりもする。ユーザが増えれば基本的なコマンドも非常に遅くなるし、中央サーバが落ちると全く仕事ができない。

それと比べるとgitはシンプルで、ワーキングディレクトリの.gitディレクトリに必要なものが全て入っている。gitはいつでも.gitディレクトリからファイルの状態を復元できるので安心感がある。

== 完全性 ==

暗号というと情報を秘密にしておくことだと思われるかも知れないが、情報を保全するという意味でも重要だ。ハッシュ関数をうまく使えばデータの（事故での、あるいは意図的な）崩壊を防ぐことができる。

SHA1ハッシュとは、あらゆる文字列に対してユニークに生成される160bitのID番号だと思えばいい。あらゆるというのは無限ではないが、無数だ。

SHA1ハッシュはそれ自体が文字列なので、それのハッシュも作れる。するとハッシュチェーンという概念ができあがる。Gitがこのハッシュチェーンを使ってデータの完全性を保証している様子は後述する。

簡単に言うと、Gitはデータを.git/objectsディレクトリに保管していて、そこには普通のファイル名の代わりにこれらのIDが入っている。IDをファイル名（そしてロックやタイムスタンプ）として使うことでただのファイルシステムを堅牢なデータベースシステムと化している。

== 知的性 ==

Gitはどうやってファイルの移動を認識しているのだろう？ git mvを使ったから、ではない。git mvは単にgit rmしてぎgit addしているだけだからだ。

Gitはヒューリスティックなやり方でリネームやコピーを判定している。なんとコードの塊がファイルからファイルへと移されたことまで認識できているのだ。もちろん完全ではないが十分強力だし、常に進化している。もしうまく行っていなかったらもっと複雑なコピー判定をオプションで有効にするとか、アップグレードするとかの方法を試してみるといい。


== インデックス ==

トラックしている全部のファイルについて、gitはサイズ、作成時刻、変更時刻をインデックスと呼ばれるファイルに保管している。ファイルが変更されたかどうかは現状とインデックスにキャッシュされたものを比較して判断する。

これらの情報を読み取るのはファイル読み込みよりかなり早いため、編集したファイルが少なければ更新状況を一瞬で判定できる。

前述したが、インデックスとはステージングエリアだった。addコマンドはファイルをgitのデータベースに入れてこれらの情報を更新する。commitコマンドはこれらの情報に基づいてコミットを作成している。


== gitの起源 ==

[http://lkml.org/lkml/2005/4/6/121 Linuxカーネルのメーリングリスト]で、Git誕生までの経緯が読める。とても興味深い内容だ。

== オブジェクトデータベース ==

管理中のデータの全バージョンはオブジェクトデータベースに保管されている。これは.git/objectsにある。他の.git/内のディレクトリはもう少しライトウェイトなもので、インデックス、ブランチ名、タグ、オプション、ログ、現在のHEADの位置などが保管されている。オブジェクトデータベースは基本的だがエレガントな設計で、Gitのパワーの源でもある。

.git/objectsにあるファイルはそれぞれがobjectだ。objectには主に3種類ある。blob、tree、そしてcommitだ。

== Blob ==

まずちょっと試してみて欲しい。なにか好きなファイル名を頭に思い浮かべよう。空のディレクトリで
    $ echo sweet > YOUR_FILENAME
    $ git init
    $ git add .
    $ find .git/objects -type f
出力は
   .git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d 
だっただろうか。

なぜファイル名を知らないのに分かったのかというと、これが
    "blob" SP "6" NUL "sweet" LF
のSHA1ハッシュだからだ。SPはスペース、NULはnull文字でLFは改行だ。次のコマンドで確かめられる。
    $ printf "blob 6\000sweet\n" | sha1sum
Gitはコンテンツアクセス可能であると言える。すなわち、ファイルはファイル名で保存されているのではなく、内容のデータのハッシュで保存されている。この保存先をblobオブジェクトという。ハッシュはファイルの内容を表したユニークなIDだから、ファイルに対して内容でアクセスしていることになる。

こういうトリックであなたの得る出力が分かったのだ。

同じ内容のファイルが2つあったらどうなるか不思議に思われるかも知れない。ためしにファイルをコピーしてみると、.git/objectsの中身は増えないことが分かるだろう。gitは同じデータは一度しか保存しない。

ちなみに、.git/objectsのファイルはzlibで圧縮してあるので直接見ると目を痛める。[http://www.zlib.net/zpipe.c zpipe -d]を通すか、
    $ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
を使おう。 


== Tree ==

ではファイル名はどこへ行ったのだろう？どこかに保存されているはずだが。

Gitはコミット時にファイル名を扱う。
    $ git commit  # Type some message.
    $ find .git/objects -type f
すると3つのオブジェクトがあるだろう。今回はファイル名によって変わるので新しいオブジェクトの名前を当てることはできない。とりあえずroseというファイル名を選んだとしよう。もし選んでなかった場合は歴史を書き換えよう。
    $ git filter-branch --tree-filter 'mv YOUR_FILENAME rose'
    $ find .git/objects -type f
これで
    .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9
というファイルができたはずだ。これは次の文字列のSHA1ハッシュである。
    "tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
このファイルを確かめるとたしかにこの内容が書かれている。
    $ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
zpipeでは
    $ zpipe -d < .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
これはtreeオブジェクトだ。ファイルタイプ、ファイル名、そしてハッシュが入っている。この例ではroseは通常のファイルなのでファイルタイプは100644、ハッシュはroseファイルの内容から生成されたblobオブジェクトだ。他にも実行ファイル、シンボリックリンクやディレクトリといったフィアルタイプが有りうる。ディレクトリならばハッシュはまた別のtreeオブジェクトを指すことになる。

filter-branchを使ったなら、要らないファイルが残っているだろう。指定の期間が経てば勝手に削除されるが、今回の実験をわかりやすくするためにあえて削除しておこう。
    $ rm -r .git/refs/original
    $ git reflog expire --expire=now --all
    $ git prune
本物のプロジェクトではこういったコマンドはバックアップを破壊するので基本的にあまり実行しないほうがいい。キレイなレポジトリが欲しければクローンしなおそう。また、.gitディレクトリを直接操作すると妙なことになりやすいのでこれも避けたほうがいい。

== コミット ==

残るオブジェクトはcommitオブジェクトだ。内容はコミットメッセージと時刻によって変わる。本書の設定とあなたの設定を同じにするために少し手を加えよう。
    $ git commit --amend -m Shakespeare  # Change the commit message.
    $ git filter-branch --env-filter 'export
        GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
        GIT_AUTHOR_NAME="Alice"
        GIT_AUTHOR_EMAIL="alice@example.com"
        GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
        GIT_COMMITTER_NAME="Bob"
        GIT_COMMITTER_EMAIL="bob@example.com"'  # Rig timestamps and authors.
    $ find .git/objects -type f
これで
    .git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187
と出力されたはずだ。これは次の文字列のSHA1ハッシュである。
    "commit 158" NUL
    "tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
    "author Alice <alice@example.com> 1234567890 -0800" LF
    "committer Bob <bob@example.com> 1234567890 -0800" LF
    LF
    "Shakespeare" LF
先ほどと同じようにzpipeやcat-fileで確認してみよう。

これは最初のコミットなので親コミットが無いが、これ以降のコミットには必ず親コミットの情報が記載される。

== 魔法と区別がつかない ==

Gitの秘密はあまりにシンプルに見える。適当に組んだCのコードとシェルスクリプトで数時間で書けてしまいそうに思える。実は当初のgitとはそういうものだった。だが今では巧妙な圧縮技術と巧妙なインデックス技術による時間と要領の節約だけでなく、普通のファイルシステムをバージョン管理のための完璧なデータベースにしてしまっている。

たとえば、あるファイルがディスクエラーで壊れてしまったとしたら、ハッシュが内容と一致しなくなるのですぐにわかる。またハッシュのハッシュを取っておくことで全てのレベルで完全性を維持できる。オブジェクトデータベースは停電などに影響を受けないのだ。

攻撃者に対しても防御できる。誰かが密かにフィルの内容を変更したような場合、ハッシュも一緒に変更しないといけない。するとそのツリーに関係する全てのコミット、そしてそれらのまたハッシュを全部変えないと整合性が取れない。こうしてハッシュの不一致をたどっていけば変更されてしまったファイルを特定できるし、どのコミットでそれが起こったのかも分かるというわけだ。

つまり、コミットを表す20バイトさえ無事ならば、Gitレポジトリを破壊することはできないのだ。

Gitのブランチ、マージ、タグなどの機能は枝葉末節である。HEADは.git/HEADファイルに保管されていて、そこにはcommitオブジェクトのハッシュが書いてある。コミットなどを行うとハッシュが書き換わる。ブランチもほぼ同じで、.git/refs/headsに保管されている。タグは.git/refs/tagsだ。



<references/>

{{Nav
|prev=GitMagic/Chapter7
|next=GitMagic/AppendixA
}}
