<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第5章 歴史の授業}}
{{Nav
|prev=GitMagic/Chapter4
|next=GitMagic/Chapter6
}}

== 第5章 歴史の授業 ==

Gitはその分散という特徴ゆえ、履歴の編集が簡単だ。でも注意して欲しい。履歴を編集するときは、自分だけが持っている履歴だけを扱おう。あなたのクローンと他の誰かのクローンでどこか履歴が食い違っていると、くっつけたときにかなり厄介なことになる。

履歴はいかに不格好であろうともimmutable（不変）であるべきだと主張する向きもいるし、公開する前にある程度取り繕うべきだとする人もいる。Gitは両方の観点を満足させられる。クローン、ブランチ、マージと同様に、歴史の書き換えはあなたに与えられた力なのだ。賢く使おう。

== もとい ==

コミットしてしまったがメッセージを間違えた、というときは
    $ git commit --amend
でさっきのメッセージを変更できる。ファイルを追加し忘れたなら
    $ git add file.txt
    $ git commit --amend
で大丈夫だ。

もっと色んな変更をさっきのコミットに追加したいときは
    $ git commit --amend -a


== もっともとい ==

もっとひどい事になってしまっていたらどうしよう。何回もコミットを重ねたがそれらの順番や分け方が気に入らない。メッセージがタイポってる部分もある。それなら
    $ git rebase -i HEAD~10
すると直近の10コミットがエディタで開く（環境変数$EDITORで指定されたものが開く）。
    pick 5c6eb73 Added repo.or.cz link
    pick a311a64 Reordered analogies in "Work How You Want"
    pick 100834f Added push target to Makefile
ここでは（git logと違って）コミットが古い順に並んでいる。この例だと5c6eb73が一番古くて100834fが一番新しい。ここで履歴を編集できる。

* 行を削除するとコミットが完全になかったことになる。
* 行の順番を入れ替えるとコミットの順番が変わる。
* pickを…
** editに書き換えるとあとで修正できる。
** rewordに書き換えるとメッセージを変更できる。
** squashに書き換えると直前のコミットとくっついて一つになる。
** fixupに書き換えるとsquashした上でメッセージを破棄する。

たとえばこういうふうに2つ目のpickをsquashに書き換えてみる。
    pick 5c6eb73 Added repo.or.cz link
    squash a311a64 Reordered analogies in "Work How You Want"
    pick 100834f Added push target to Makefile
保存してエディタを終了すると、a311a64が5c6eb73と一つになる。そしてログメッセージもつなぎあわせ、その編集を求めてくる。squashの代わりにfixupにしていたらログメッセージは単に破棄される。

コミットをeditとマークしたら、その時点まで巻き戻される。前節で紹介した要領でこのコミットをamendすることができる。新しいコミットを作ることも可能だ。満足したら、このコマンドで履歴編集を続行する。
    $ git rebase --continue
すると次のeditまで、あるいはもうeditがないなら最新まで早送りされる。

また、
    $ git rebase --abort
とすれば履歴編集全体を中止することもできる。

というわけで、頻繁にコミットしておけばあとでrebaseを使ってキレイにできるわけだ。


== ローカルの変更を最後に持ってくる ==

アクティブなプロジェクトに関わっているとしよう。ローカルでいくつかコミットしてからオフィシャルなツリーとマージすることになる。

するとローカルのクローンではあなたのコミットとリモートでのコミットが混ざり合った形になってしまう。オフィシャルな変更のあとにあなたのコミットを全部持ってきたいと思うだろう。

これも先ほどのgit rebaseで行える。'''--onto'''オプションを使えばインタラクティブでないやり方で行える。

より詳しくは'''git help rebase'''を確認しよう。この素晴らしくパワフルなコマンドの全貌を例を交えて説明してくれる。コミットを分割したりブランチを繋ぎ変えたりもできてしまう。

ただしrebaseはあまりにパワフルなコマンドなので気をつけよう。複雑な作業をする前にまずcloneでバックアップを取っておくのがおすすめだ。


== 歴史を書き換える ==

Photoshopでは写真から要らない木を消したりできるが、たまにバージョン管理でも同様のことをする必要が出てくる。たとえばプロジェクトをリリースするのだがパスワード等の入ったプライベートなファイルが含まれてしまっているとかだ。ファイルを削除するだけでは履歴に残っているので不十分で、すべてのコミットからこのファイルを削除せねばならない。

    $ git filter-branch --tree-filter 'rm top/secret/file' HEAD

詳しくは'''git help filter-branch'''を見て欲しいが、一言で言うと大量の履歴を一度に書き換えるコマンドだ。

最終的に、.git/refs/originalというディレクトリが作業前の状態を反映している。満足ならばこのディレクトリを削除しよう。

また、以前の状態のクローンを取っていた場合は取り直そう。


== 歴史を作る ==

プロジェクトをgitに移行したい？人気のバージョン管理システムを既に使っているなら、おそらくgit移行用のスクリプトを誰かが書いているので探してみるとよい。

そうでない場合、'''git fast-import'''を使おう。これはテキストファイルを読み込んでgitの履歴を生成するコマンドだ。

試しにこのファイルをどこか適当なファイル（/tmp/historyなど）に保存しよう。
    commit refs/heads/master
    committer Alice <alice@example.com> Thu, 01 Jan 1970 00:00:00 +0000
    data <<EOT
    Initial commit.
    EOT

    M 100644 inline hello.c
    data <<EOT
    #include <stdio.h>

    int main() {
        printf("Hello, world!\n");
        return 0;
    }
    EOT


    commit refs/heads/master
    committer Bob <bob@example.com> Tue, 14 Mar 2000 01:59:26 -0800
    data <<EOT
    Replace printf() with write().
    EOT

    M 100644 inline hello.c
    data <<EOT
    #include <unistd.h>

    int main() {
        write(1, "Hello, world!\n", 14);
        return 0;
    }
    EOT
このファイルからgitレポジトリを作成するには、
    $ mkdir project; cd project; git init
    $ git fast-import --date-format=rfc2822 < /tmp/history
    $ git checkout master .

逆に'''git fast-export'''コマンドはレポジトリをfast-import形式に出力してくれるので、それを参考にexportスクリプトを書くと良いかも知れない。また、fast-exportを使ってレポジトリをメールで送信するなんていう技も可能だ。


== どうしてこうなった？ ==

数カ月前はたしかに動いてた機能がなぜか動かない！このバグはどこで発生したのだろう？

もし頻繁にコミットしていたならgitが診断に役だってくれる。
    $ git bisect start
    $ git bisect bad HEAD
    $ git bisect good 1b6d
するとちょうど半分の時点の状態を復元してくれる。機能が動作しているか確認して、やはりダメなら
    $ git bisect bad
動いていればgoodとする。これでまたgoodとbadのちょうど半分のところまで移動してくれる。2分探索なので数回繰り返せば問題の発生源に辿りつけるだろう。原因が判明したら
    $ git bisect reset
で一番最初の状態に戻れる。

ジャンプのたびに手動で動作確認をしなくても、
    $ git bisect run my_script
とすればこのコマンドの返り値を見て判断してくれる。goodのときは0、その時点をスキップするときは125、それ以外の1〜127までの値はbadとみなされる。負の値を返せばbisectが中止される。

bisectもっと色々機能があって、プロセスを可視化したり、bisectログを再生したり、特定の変更を無視したりもできるので、ヘルプを確認して見て欲しい。


== 誰のせいでこうなった？ ==

他のバージョン管理システムと同じく、gitにもblame（誰のせい）機能がついている。
    $ git blame bug.c
するとそのファイルの全ての行について、誰がいつ最後に編集したかが表示される。


== 私の経験談 ==

集中バージョン管理システムでは履歴の変更は難しい作業で、普通は管理者しか実行できない。それにクローン、ブランチ、マージはネットワーク接続がないと動作しない。もちろん履歴の参照やコミットもそうだ。自分の変更点を見たりファイルを編集するだけでもネットワーク接続が必要な場合もある。

基本的に集中バージョン管理システムではオフライン作業というのはできないと言えるし、開発者の数が増えればそれだけインフラのコストもかかる。それに大抵の処理は遅いので、複雑なコマンドは本当に必要な時しか実行しないようになってしまう。遅いコマンドを実行するのは生産性に毒だ。

私は身を持ってこういう体験をしてきた。初めて使ったのがgitで、そのいろんな機能を当たり前と思うようになっていた。他のバージョン管理システムもそう違わないはずだと思っていた。

その後集中バージョン管理システムを使わざるを得ない事があって、それはもう衝撃的だった。ネットワーク接続が不安定だと開発がままならない。時間がかかるからいくつかのコマンドは打たないようになり、望ましいワークフローから逸脱していった。

実際に遅いコマンドを使ったら思考の流れが中断されてかなりのダメージを負った。転送終了を待つ間何か別のこと（メールに返信するとか）をしていて、戻ると既に処理は終わっているが、何をやろうとしていたか思い出すのに手間取ることも多かった。人間はコンテキスト切り替えが下手なのだ。


<references/>

{{Nav
|prev=GitMagic/Chapter4
|next=GitMagic/Chapter6
}}
