<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第4章 ブランチの魔術}}
{{Nav
|prev=GitMagic/Chapter3
|next=GitMagic/Chapter5
}}

= 第4章 ブランチの魔法 =

一瞬でブランチとマージができるのがgitのキラーフィーチャーの中でも最も殺人的に便利な機能だ。

'''問題''': 色んな要因によって、必ずコンテキストを切り替える必要が出てくる。リリースしたバージョンで致命的なエラーが発見されるとか、ある機能の締め切りが急に早まったとか、キーパーソンである開発者が退職することになったとかだ。こういったケースでは今やっている事を中断して別のタスクに取り掛からなければいけない。

作業と思考を中断するのは生産性を殺してしまう。コンテキストを切り替えるのに手間取れば手間取るほどダメージも大きい。集中バージョン管理システムだと、中央レポジトリからフレッシュな内容をダウンロードし直さなければならない。その点、分散管理はローカルだけで好きな版をクローンできるのでマシだ。

だが、クローンにはやはりワーキングディレクトリ全体とその履歴のコピーが伴う。gitはファイルの共有とハードリンクでこのコストを低減しているが、ファイル自体は新しく再現しなおさなければいけない。

'''解決''': gitには、大幅に早くて容量も食わない'''git branch'''というツールがある。

この魔法を使うと、ワーキングディレクトリ内のファイルが突如、別の版へと姿を変える。この操作は履歴を前後に移動するだけに限らず、最新リリースから実験版へ、開発版へ、友だちのバージョンへと自在に切り替えられる。

== ボスが来たボタン ==

上司が来たら咄嗟にボタンを押す。すると画面にExcel風の画面を表示してくれる。そんな機能がついてるゲームをやったことがあるだろうか？

適当なディレクトリで以下の操作をしよう。
    $ echo "私の上司は大アホだ" > myfile.txt
    $ git init
    $ git add .
    $ git commit -m "Initial commit"
とあるメッセージを含んだファイル1つだけを管理するレポジトリができた。次に、
    $ git checkout -b boss  # ここでは何も変わらないように見える
    $ echo "私の上司は最高だ" > myfile.txt
    $ git commit -a -m "Another commit"
ファイルを上書きしてコミットしたように見えるが、実はちがう。
    $ git checkout master  # 元のファイルに切り替える
こうするとファイルが最初の状態に戻るのだ。
また上司が来たら、今度はこうだ。
    $ git checkout boss  # 上司向けのファイルに切り替える
2つのブランチは自由に切り替えられれ、それぞれの先に新しいコミットを追加できる。


== 汚い仕事 ==

ある機能を開発していて、何かの実装を確認したくなったなどの理由で、3つ前のバージョンに戻っていくつかprint文を挿入してみたくなったとしよう。

まずは
    $ git commit -a
    $ git checkout HEAD~3
これで適当なコードをそこら中に散りばめて現状確認ができる。なんならコミットさえできる。終わったら
    $ git checkout master
とすれば元の状態へ戻れる。未コミットの変更は維持されていることに注意しよう。

一時的だと思った変更をやっぱり保持したいと思ったら？
    $ git checkout -b dirty
として、コミットしてからmasterブランチに切り替えればいい。

一時的な方に戻りたければいつでも
    $ git checkout dirty
とすれば戻れる。

このコマンドについてはすでに軽く触れたが、ちゃんと説明すると、ファイルは指定した状況へと切り替わるが、masterブランチを後にしていることになるのだ。ここから加えた変更は本筋から分岐して別の道へ進む。この道筋にはあとで名前（ブランチ名）をつけることができる。

言い換えると、古いバージョンをチェックアウトすると、無名の新しいブランチに自動的に移動するのだ。そして'''git checkout -b'''でこのブランチに名前をつけることができる。


== ちょっとした修正 ==

今やっていることを中断してコミット1b6d...で見つかったバグを修正してくれと言われたら、
    $ git commit -a
    $ git checkout -b fixes 1b6d
この状態でバグを修正する。修正できたら
    $ git commit -a -m "Bug fixed"
    $ git checkout master
として元のタスクに戻る。先ほどのバグフィックスを今のワーキングディレクトリに適用することもできる：
    $ git merge fixes


== マージ ==

バージョン管理システムでよくあるのは、ブランチを作るのは簡単だがマージするのは面倒というケースだ。ところがGitではあまりにマージが簡単なのでマージしたことに気づかない（こともある）くらいだ。

実は既に紹介した手順の中にマージがあった。'''pull'''コマンドだ。これはコミットをまず取得するだけして（'''fetch'''）、それを今のブランチにマージしている。もし前回のpull以来ローカルで変更がなければ、このマージはfast-forward（早送り）と言われ、集中バージョン管理における一方的な更新（ダウンロード）と似ている。もしローカルに変更があれば自動的にマージされ、衝突があれば教えてくれる。

普通コミットには1つだけ親コミットが存在する。すなわち直前の版である。ところがブランチ同士をマージすると、複数の親コミットを持つコミットが誕生する。すると不思議なのは、HEAD~10（最新の10コ前のコミット）とは一体どれを指すのだろう？親が複数あるなら辿れないではないか？

実はこの書き方をすると、必ず「最初の親」の方へ辿ってくれる。これは望ましい仕様で、なぜならマージした時に「今いるブランチ」が「最初の親」になるからだ。通常、気になるのは現在いるブランチで加えた変更だけで、他のブランチからマージされた変更点はあまり重要でないことが多いのでこれでよい。

ハット（^）を使えば特定の親を参照できる。たとえば「二番目の親」のログを見たければ
    $ Git log HEAD^2
とする。「最初の親」を見たければ1だが、これは省略できる。
    $ git diff HEAD^
他のバージョン指定方法と組み合わせてもいい。
    $ git checkout1b6d^^2~10 -b ancient
とすると、1b6dの「2つ目の親」の10コミット前の状態から新しいancientというブランチを切ることができる。


== 障壁なきワークフロー ==

ハードウェアプロジェクトではよく、ある行程が完了していなければ次の工程へ進めないような状況がある。修理中の車はパーツが届くまで何もできないとか、あるチップが完成しないとプロトタイプが作れないとかだ。

ソフトウェアでも同様のケースは有りうる。ある機能の後半の実装は前半が終わらないとできないかったり、コードレビューが通らないと次へ進めなかったりする。

gitでは即座にブランチを切ったりマージしたりできるので、こういった状況でもあまり困らない。まだできないはずの作業を先にやってしまえるのだ。

例えばPart 1を実装してレビュー待ちの状態だとしよう。今、masterブランチにいるとして、まずはブランチを切る。
    $ git checkout -b part2
これでPart 2の作業に入る。途中、好きなだけコミットすればよい。人は誰でも過ちを犯すものだから、Part 1のコードを修正したくなることもあるだろう。そんなときは
    $ git checkout master  # Part 1へ戻る
    $ fix_problem
    $ git commit -a        # 修正をコミット
    $ git checkout part2   # Part 2へ戻る
    $ git merge master     # 修正をマージ
やがてPart 1がレビューに通ると、
    $ git checkout master  # Part 1へ戻る
    $ submit files         # リリースする！
    $ git merge part2      # Part 2をマージする
    $ git branch -d part2  # Part2ブランチを削除する。
これでmasterブランチに戻って、Part 2の内容が反映されていることになる。また、過去の変更をブランチとして切るのも簡単だ。7コミット前でなぜブランチを切らなかったんだろう。そんなときは
    $ git branch -m master part2  # masterブランチをpart2にリネーム
    $ git branch master HEAD~7    # 7個前から新しくmasterというブランチを開始する
これでmasterブランチにはPart 1だけがあり、残りはpart2ブランチになった。今はpart2ブランチにいる。masterブランチは切っただけでそちらに切り替えてはいない。これまでは
    $ git checkout HEAD~7 -b master  # ブランチを作ってそこへ移動
としてきたが、切ると同時に切り替えなくてもいい。


== メドレーの編曲 ==

もしかするとプロジェクトの全部の作業をひとつのブランチでやりたいかも知れない。作業中の内容を誰にも見せず、ある程度形が整ったときに初めて共有したいかも知れない。

まずはブランチを2つ作ろう。
    $ git branch sanitized    # キレイなコミット専用ブランチ
    $ git checkout -b medley  # 作業用ブランチ
この状態で開発なりデバッグなりの作業をする。頻繁にコミットしよう。気がすんだら、
    $ git checkout sanitized
    $ git cherry-pick medley^^
こうするとmedleyブランチのHEADから2つ上流のコミットがsanitizedブランチに適用される。こうしてcherry-pick（よりすぐり）していくことで本番に相応しいコードだけ、それも関連するコミットどうしをまとめて適用していくことが可能だ。


== ブランチの管理 ==

全ブランチの一覧を見るには
    $ git branch
デフォルトではmasterというブランチにいる。このmasterブランチは使わずに（というか特定の用途に使うためにとっておいて）別のブランチで作業をすべきだと言う人もいる。

'''-d'''オプションでブランチが削除できて、'''-m'''オプションでブランチの名前を変更できる。詳しくは'''git help branch'''をチェックしよう。

"master"という名前は慣例として便利だ。あなたのレポジトリにはmasterというブランチが必ずあって、そこにはオフィシャルなコードがあると推測する人も少なくないだろう。どうせなら慣例に則っておこう。


== 一時的なブランチ ==

優先度の高いバグ修正などのために、一時的に現状を別のブランチに切っておいて、戻って作業をするということが頻繁に起こったりする。テレビのチャンネルをちょっと変えてみるようなものだが、ボタン一発というわけにはいかない。ブランチを作成して、チェックアウトして、マージして、削除しなければいけない。

そのためにGitには本当にボタン一発のコマンドが用意されている。
    $ git stash
こうすると現状を一時的な場所（スタッシュ）に保管して前のコミットまで戻してくれる。ここでバグを修正したりpullしたりできる。スタッシュの内容を復元するには
    $ git stash apply  # 衝突は発生するかもしれない
スタッシュはいくつでも作れるし、いろんな操作ができる。詳しくは'''git help stash'''を見よう。お察しの通り、実は裏でブランチを操作してくれている。


== やりたいように ==

ブランチなんてほんとうに必要なのかと疑問に思われるかも知れない。cloneだって十分早いのだから、色々とコマンドを覚えなくてもcloneしてcdしてという流れで十分じゃないかと。

Webブラウザを考えてみて欲しい。なぜマルチウィンドウに加えてタブブラウジング機能があるのだろう？そうすることで使い方の幅が広がるからだ。ある人はウィンドウ一つの中にいっぱいタブを開くのが好きかもしれない。またある人はタブを全く使わずウィンドウを山のように開くのが好きかもしれない。その間の人もいるだろう。

ブランチは、ワーキングディレクトリのタブのようなもので、クローンはブラウザのウィンドウを開くようなものだ。いろいろな組み合わせを試してもっとも作業がしやすいやり方を見つけよう。


<references/>

{{Nav
|prev=GitMagic/Chapter3
|next=GitMagic/Chapter5
}}
