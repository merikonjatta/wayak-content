<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第7章 グランドマスター}}
{{Nav
|prev=GitMagic/Chapter6
|next=GitMagic/Chapter8
}}

= 第7章 グランドマスター =

ここまで読み進めてきたあなたはすでに、git helpのページでほとんどなんでも理解できるようになっていると思う。それでも、特定の問題を解決するために必要なコマンドはどれか、というのを調べるのはなかなか面倒なものだ。以下では私がこれまでに遭遇した問題とその解決レシピを紹介したい。

== ソースリリース ==

ソースパッケージとしてリリースしたい時、そこに含めるべきファイルはちょうどgitが管理してくれている。次のコマンドでtarballを作れる。
    $ git archive --format=tar --prefix=proj-1.2.3/ HEAD


== 変更点全部をコミット ==

追加、削除、移動したファイルをgitに登録していくのは面倒な場合もある。そういうときは
    $ git add .
    $ git add -u
とすればあとはよしなにやってくれる。同時にコミットもするなら2つ目のコマンドの代わりに
    $ git commit -a
を使えばいい。特定のファイルを無視する設定に関してはgit help ignoreを見て欲しい。

これらの作業は次のコマンドで一発でできる。
    $ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
-zと-0オプションはファイル名などに変な文字が含まれても大丈夫なようにするオプションだ。ただしこれでは無視ファイルも含まれてしまうので、-xか-Xオプションを使ったほうがいいかも知れない。


== コミットが大きすぎる ==

長い間コミットしていなかった？コーディングに集中しすぎてコミットを忘れていた？色々と関係のない変更を一度にしている？
    $ git add -p
をするとそれぞれの変更点について、次のコミットに含めるべきかどうかを尋ねてくれる。yとn以外にも保留などのオプションがある。その他については?を押してみるとわかる。

気がすんだらgit commitで選んだ部分（stageされた部分）だけをコミットできる。-aをつけてしまうと全部の変更点が含まれるのでつけてはいけない。

大量のファイルに変更点が分散しているときはこの作業が面倒になることもある。その場合は'''git add -i'''を使えばいい。インタフェースは少しわかりにくいが、より柔軟な作業ができる。幾つものファイルを同時にstageしたり、特定のファイルの変更点だけを確認したりできる。また、git commit --interactiveならこの作業の後自動的にコミットもしてくれる。


== インデックス：ステージングエリア ==

ここまで、gitの特徴的な概念であるインデックスを無視して話を進めてきたが、上の例の理解のためにここで少し説明しておきたい。インデックスとは、ステージングエリア、あるいは中間地点のことだ。gitはワーキングディレクトリから履歴へ直接データを反映させることはほとんどない。まずインデックスに書きこんでから、それを履歴へ反映させるようになっている。

つまりcommit -aは実際には2段階の処理になっている。最初は管理下のファイルの現状をインデックスに置く。次にインデックスから永続的な記録へと移す。-aをつけずにコミットすると2段階目しか行われないので、インデックスを変更するなんらかの操作（git addなど）のあとで実行して初めて意味がある。

普通はこの動きは意識しなくてもよくて、ファイルの状態が直接履歴へ行くと考えればいいが、たまに細かい操作をしたいときはインデックスの状態を意識したほうがいい。例えば上述のコミットが大きすぎる例では一部の変更だけをインデックスに入れて、それをコミットした。


== HEADを見失わない ==

HEADというタグはカーソルのようなもので、普段は直近のコミットを指していて、新しくコミットするごとに前へ移動する。が、このカーソルを移動させるコマンドもあるたとえば
    $ git reset HEAD~3
とするとHEADが3つ巻き戻る。するとそれ以降のコミットがなかったかのようになる（ファイルの状態は維持される）。より詳しくはヘルプを見て欲しい。

では未来へ行きたかったらどうすればいいだろう。過去のコミットは未来のことは知らない。

元のHEADのSHA1ハッシュが分かっているなら
    $ git reset 1b6d
とすればよい。これをメモしていなかったら？そんなときは元のHEADをORIG_HEADというタグで保管してくれているので、そこへ戻ればいい。
    $ git reset ORIG_HEAD


== HEADハンティング ==

ORIG_HEADでは不十分な時もあろう。重大な失敗に気がついて昔のコミットに戻らなければいけないこともあるかもしれない。

gitはデフォルトではブランチを削除した後2週間はコミットを保管している。が、難しいのは対応するハッシュを見つけることだ。.git/objectsの全部のハッシュを一つ一つ確認していくというのは無理がある。

gitはハッシュを計算した全部のコミットについて.git/logsに記録している。このなかのrefsディレクトリにはそれぞれのブランチに関する情報があり、HEADファイルには行ったことのあるハッシュが全部書かれている。

これらのログファイルに簡単にアクセスするコマンド
    $ git reflog
がある。これの結果を見ながら
    $ git checkout "@{10 minutes ago}"
とか
    $ git checkout "@{5}"
とかを使えばうまく移動できるだろう。詳しくはgit help rev-parseの"Specifying Revisions"の節を見て欲しい。

猶予期間を長く設定することもできる。
    $ git config gc.pruneexpire "30 days"
するとgit gcが走って削除済みコミットが本当に削除されるまでの期間が30日になる。

git gcの自動実行自体をオフにしてしまうのもありだ。
    $ git config gc.auto 0
この場合、git gcを手動で起動した時だけ削除が行われる。


== Gitを拡張する ==

Gitのデザインは、他のGUIやWebインターフェース、CUI、インポートや変換ツールなどのバックエンドとして簡単に使えるという実にUNIXらしいものになっている。実際、gitコマンドのいくつかはそれ自体、コアコンポーネントに乗っかっただけの形である。カスタマイズして挙動を変更するのも比較的簡単だ。

まず最も簡単なのはエイリアスの設定だ。よく使うコマンドには短いエイリアスを与えよう。
    $ git config --global alias.co checkout
    $ git config --global --get-regexp alias  # 設定されているエイリアスを見る
    alias.co checkout
    $ git co foo                              # 'git checkout foo'と同じ

また、現在のブランチ名をターミナルのタイトルに表示するなんてこともできる。
    $ git symbolic-ref HEAD
を実行すると現在のブランチ名が表示される。実際にはrefs/heads/の部分を削除してエラーも抑制したほうがいいだろう。
    $ git symbolic-ref HEAD 2> /dev/null | cut -b 12-
   
contribディレクトリはgitの上に作られたツールの宝箱だ。中には将来、公式に取り上げられるものもあるだろう。DebianかUbuntuだとこのディレクトリは/usr/share/doc/git-core/contribにある。

中でも人気の高いのは workdir/git-new-workdir だ。シンボリックリンクをうまく使って元のレポジトリと履歴を共有した新しいレポジトリを作成してくれる。
    $ git-new-workdir an/existing/repo new/directory
これら2つのディレクトリはクローンにも似ているが、履歴は完全に共有されているため、片方に加えた変更はもうひとつに自動的に同期される。


== 危ない技 ==

最近のgitでは誤ってデータを壊してしまうような使い方はなかなか難しくなっている。でももし確信があるなら危ない技も使える。

'''チェックアウト''': コミットしていない変更があるとcheckoutは実行できない。それらを破棄して無理やりcheckoutするにはforceフラグを使う。
    $ git checkout -f HEAD^

逆に、checkoutに特定のパスを指定するとセーフガードが働かないので注意しよう。

'''リセット''': リセットもコミットしていない変更があると実行できないが、無理やりリセットするには
    $ git reset --hard 1b6d

'''ブランチ''': 同じくブランチの削除も変更が破棄されるような場合は実行できない。無理やり削除するには
    $ git branch -D dead_branch  # -dじゃない
また、ブランチを無理やり移動するには
    $ git branch -M source target # -mじゃない
checkoutやresetと違ってこれらのコマンドは変更を完全には破棄しない。これらは.gitディレクトリに保管されているので、上述のHEADハンティングで復帰できる。これもデフォルトでは2週間である。

'''クリーン''': 管理下でないファイルに影響を与えてしまうという理由で完遂できないコマンドもある。管理下でないファイルが絶対に要らないと分かっているなら削除してしまえる。
    $ git clean -f -d


== 悪い癖を予防する ==

たまに下らないミスでレポジトリが汚染されることがある。一番怖いのはgit addのし忘れでファイルがどこかへ行ってしまうことだ。他にも行末のホワイトスペースや、解消し忘れのマージコンフリクトなどがある。

そこで保険としてフックを設定できる。
    $ cd .git/hooks
    $ cp pre-commit.sample pre-commit  # 古いgitでは chmod +x pre-commit
これでホワイトスペースや解消していないコンフリクトがあるとコミットを中止してくれる。

この本のレポジトリでは次のようなpre-commitフックを使っている。
    if git ls-files -o | grep '\.txt$'; then
      echo FAIL! Untracked .txt files. # アッー！txtファイルがトラックされてないよ
      exit 1
    fi

フックは色々なところに設定できる。git help hooksを参照して欲しい。HTTPに関する節ではpost-updateフックを有効にした。これはHEADが移動するたびに起動される。


<references/>

{{Nav
|prev=GitMagic/Chapter6
|next=GitMagic/Chapter8
}}
