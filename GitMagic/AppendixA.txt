<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=付録: ダメなところ}}
{{Nav
|prev=GitMagic/Chapter8
}}

= 付録: ダメなところ =

これまで秘密にしてきたgitの問題点をここでは紹介する。スクリプトやフックで簡単に解決できるものもあればプロジェクト全体を整理し直さなければいけないものもある。現時点で対策のないものもあるが、それで困っている人はぜひgit本体の開発に参加していただきたい。

== SHA1の弱点 ==

時間の経過と共に暗号技術者はSHA1ハッシュの弱点を次々と見つけている。既にハッシュ値の衝突を見つけるのは現実的だ。数年後には普通のPCでも密かにgitレポジトリを壊す力を持つかも知れない。

願わくばそれまでにSHA1より優れたハッシュ値を導入して欲しいものだ。

== Microsoft Windows ==

GitをWindowsで使うのはやや面倒だ。
* Windows用のLinux風環境[http://cygwin.com/ Cygwin]には[http://cygwin.com/packages/git/ 移植版] がある。
* [http://code.google.com/p/msysgit/ Git on MSys]もWindows移植版だが、やや未完成な部分もある。

== 無関係なファイル ==

プロジェクトが大きくなってきていろんな部分が常に変更されるようになってくると、gitはあまり有利でなくなる。これはgitは単一のファイルではなくプロジェクト全体を管理するからで、これは普通は良いことなのだが。

解決策としては、プロジェクトをいくつかに分割しよう。それでもひとつのプロジェクトにまとめておきたければgit submoduleを使おう。

== 誰が何を編集してる？ ==

バージョン管理システムの中には、ファイルを編集する前に明示的にマークさせるようなものもある。これはサーバと通信しなければいけないときは非常に鬱陶しいが、利点もある。

* マークしたファイルだけ調べればいいのでDiffが速い
* 誰がどのファイルを編集しているかサーバに聞けば分かる

少しスクリプトを書けばgitでも同じことが可能だ（そのスクリプトを都度実行してくれるよう開発者からの強力も必要だ）。

== ファイルの履歴 ==

gitはプロジェクト全体の変更を管理するので、特定のファイルの履歴をチェックするのには手間がかかる。

ただ、他の作業が素早くできるし、それほどの差では無いので普通は気にならない。

== 最初のクローン ==

クローンを作るのは普通のバージョン管理システムのチェックアウトと比べると、履歴を全部取得するのでやや時間がかかる。

だがこのコストは将来の作業が圧倒的に早くなるので払う価値があるだろう。そうはいかないという場合は--depthオプションをつければ浅いクローンを作れるが、結果的に生まれるクローンは機能的に限定されたものになる。


== 大きな変更 ==

Gitは普通な変更内容の時に高速で動作するようにできている。人間はそんなに大きな変更をしないものだ。数行のバグフィクス、コメントの追加などがメインだからだ。でももしコミット間でファイルの内容が大幅に違っていると、履歴のサイズがプロジェクト全体のサイズに従って大きくなってしまう。

バージョン管理システムがどうこうできる問題ではないのだが、履歴全体がクローンされるgitではこの被害が大きい。

変更量が多いときは理由を検証してみよう。ファイル形式を変換したほうがいいかもしれない。あるいはコミットを細かく分けたほうがいいかも知れない。

バージョン管理ではなくデータベースかバックアップ系のソリューションのほうが適しているかも知れない。たとえばWebカメラで定期的に撮影している写真を管理する場合などだ。

本当にバージョン管理が必要なら、gitを集中バージョン管理風に使うといいかも知れない。浅いクローンを使って少しの履歴だけチェックアウトする。もちろん、gitの色々なツールは使えなくなってしまうし、修正はパッチとして扱わないといけない。

他にもファームウェアなどの大きなバイナリを扱うのにgitは向いていない。そういう時はソースコードだけgitで管理しバイナリは別の場所で保管すべきだろう。


== グローバルなカウンター ==

バージョン管理システムによってはコミットのたびに増える数値を保管しているものがある。gitはハッシュでコミットを管理していて、多くの場合はこのほうが有利だ。

でもこのコミット番号があったほうが良いという人もいるだろう。そういうスクリプトを書くのは比較的簡単だ。中央レポジトリがコミットを受け取るたびに数字をどこか、たとえばタグなどに書いておき、コミットのハッシュと関連付けるようにすればいい。


== 空のディレクトリ ==

空のディレクトリは管理されない。管理しておきたい場合はダミーファイルを作っておくのがよい。

これはgitの設計と言うより現在の実装に問題がある。いずれ要望が多ければこの機能は実装されるかも知れない。


== 最初のコミット ==

プログラミングをする人間は1ではなく0から数え始める癖があると思うが、gitはコミットに関してこの法則に則っていない。というのは、最初にコミットする前はいろんなコマンドが使いにくいのだ。加えて別の最初のコミットへrebaseする場合などの境界条件は特別な扱いが必要になる。

コミットを0から数え始めると色んな利点があると思っている。たとえば最初にレポジトリを作ったらHEADは20個のnull文字となるなどだ。これは空のツリーで親がなくてずっと昔の時点で作られたコミットということにすればいい。

するとたとえばgit logなどを実行した時に「致命的エラー」ではなく、コミットがないというメッセージを表示できるだろう。

他のコミットは全てこのゼロコミットの子ということにすればいい。

ただ、これも必ず上手くいくとは限らないのが困ったところだ。それぞれ別の最初のコミットを親とする数個のブランチをマージしたら、結果をrebaseするのにかなりの手作業が必要になる。


== UIの欠点 ==

2つのコミットAとBがあるとき、"A..B"と"A...B"という表現は、コマンドが2つの端を受けるのかある範囲を受けるのかで違ってくる。詳しくはgit help diffとgit help rev-parseを見て欲しい。


<references/>

{{Nav
|prev=GitMagic/Chapter8
}}
