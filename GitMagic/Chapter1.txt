<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第1章: はじめに}}
{{Nav
|next=GitMagic/Chapter2
}}

[http://git.or.cz/ Git]はバージョン管理のスイスアーミーナイフだ。信頼性が高く多用途で実に柔軟ででも学ぶのは少し難しいし、マスターするのはもっと難しい。

Arthur C. Clarkeが言ったように、十分進歩したテクノロジーは魔法と区別がつかない。これはGitへのよいアプローチだと思う。初心者は内部的な構造や仕様は無視して、gitを魔法の小道具だとみなせばいいのだ。

この本では細かい事は抜きにして、素敵な使い方の方法だけを説明する。繰り返し使っていればそれぞれのトリックがどんなふうに動いていて、どんな風に工夫すれば自分のニーズにぴったり合うかが分かってくるだろう。

= 第一章: はじめに =

バージョン管理についてちょっとした比喩を使わせてもらう。もうちょっとまともな説明については[http://en.wikipedia.org/wiki/Revision_control Wikipediaの記事]などを見て欲しい。

== 仕事は遊び ==

私は生まれて以来とてもよくゲームで遊んできた。バージョン管理を使い始めたのは大人になってからだ。私のような人は多いと思うので、これらを比較することでコンセプトを分かりやすく説明してみたい。

コードやドキュメントを編集するのをゲームのようなものだと考えよう。ある程度進展があるとセーブしたくなる。そこでいつものエディタのセーブボタンを押す。

すると以前のものが上書きされて保存されてしまう。これはさながら昔懐かしのゲームのようで、セーブスロットがひとつしか無いのと同じだ。セーブできるが、昔の状態に戻ることはできない。もしかしたら以前のセーブゲームはとっても面白い部分の直前で、またそこを遊びたいと思うかも知れない。それか、どう頑張ってもクリアできない状況でセーブしてしまって、前のセーブに戻りたいと思うかも知れない。

== バージョン管理 ==

ファイルを編集のときは、「名前を付けて保存」するか、保存する前に今のファイルをどこかにコピーしておいたらいいかもしれない。増えてきたら圧縮すれば容量も節約できる。これはバージョン管理の最も原始的で、かつ労力のかかる形態だ。ゲームはというと、かなり早くにこの問題を解決していて、時刻付きでいくつもセーブファイルが作れるようになっていた。

もう少し厳しい状況を考えてみよう。幾つものファイルをセットで扱わないといけないとする。例えばソースコードのプロジェクトとか、Webサイトの構成ファイルとかだ。すると、古いバージョンを保管しておくためにはディレクトリごとコピーしないといけない。これを手動で扱うのは手間がかかるし、容量も食う。

ゲームの場合、セーブゲームというのは本当にファイルがいっぱい詰まったディレクトリであることが多い。が、選べばロードできるというシンプルなUIを提供するので、プレイヤーにはそのことは分からない。

バージョン管理システムも同じで、ファイルが詰まったディレクトリを扱う便利なインターフェースを提供してくれる。今の状態を好きなときに保存できて、ロードもできるのだ。それに、ゲームと違って容量の節約も考慮してくれる。普通バージョンとバージョンの間で変わるのは一部のファイルだけなので、変わった部分だけを保存してくれたりするのだ。

== 分散バージョン管理 ==

さて、とっても難しいゲームを想像してみよう。あまりに難しいので、全世界のゲーマーが結託し、セーブゲームを共有してクリアを目指すことになった。色んな特技を持つプレイヤーが寄り集まって、それぞれの得意分野をこなすことで素晴らしい結果を生もうというプロジェクトである。

各自が自分のセーブゲームをアップロードできて、他人のセーブゲームを入手できるようなシステムをどうやってセットアップしよう？

昔は、ほとんどのプロジェクトが集中バージョン管理を使っていた。どこかにあるサーバが全部のセーブゲームを保管していた。ゲームを進めるときは、最新のセーブゲームをサーバからダウンロードして、プレイして、新しいセーブゲームをサーバにアップロードするといった流れだ。

でももしプレイヤーが古いセーブゲームから遊びたかったら？もしかしたら誰かが牢屋の鍵を拾い忘れていて、クリアできない状況になってしまっているかもしれない。あるいは、過去の2つのセーブゲームを比べて、誰かがどんなプレイをしたのかチェックしたいかも知れない。

そんなとき、プレイヤーはサーバに、その古いセーブファイルをくれと頼むことになる。多くのセーブファイルが欲しければそれだけ通信が発生する。

これに対しgitを含む新時代のバージョン管理は分散バージョン管理と呼ばれる。プレイヤーがセーブゲームをダウンロードするとき、一度に全部のセーブファイルを入手するのだ。まるでサーバをミラーリングするかのように。

最初の通信には時間がかかるかも知れないが、長いスパンで見ると効果的だ。古いセーブファイルが欲しければいつでも通信なしで手に入るからというのが、まず一つ挙げられる理由だ。


== おかしな迷信 ==

ひとつの公式レポジトリを持つべきプロジェクトに分散バージョン管理は向かないというのは、よくある誤解だ。それも事実とかけ離れた誤解だ。人の写真を撮っても魂が抜けないのと同じで、マスターレポジトリをクローンしてもその重要性は減らない。

まず覚えておくべきなのは、集中バージョン管理ができるあらゆる事は、分散バージョン管理なら少なくとも同等にうまくできるということだ。ネットワークリソースはローカルリソースより単純にコストが高い。たしかに分散バージョン管理にも欠点はあるが、こう考えておけば誤った比較をせずに済むだろう。

小さいプロジェクトだとgitのようなシステムのごく一部の機能しか使わないかも知れないが、プロジェクトが小さいからといってスケールしないシステムを使うのは、ケタが少ないからといってローマ数字を使うようなものだ。

それに、プロジェクトはいつか想像以上のサイズに成長するかも知れない。最初からgitを使ってけば、ボトルを開けるためだけでもスイスアーミーナイフを持っておくようなもので、いつかネジを回したくなった時に栓抜きじゃなくて良かったと思えるのだ。

== マージと衝突 ==

この話をするにはゲームのたとえは無理があるので、文書を編集するケースを考えよう。

アリスがあるファイルの頭に新しい行を書き加えたとする。ボブは同じファイルの最後に新しい行を書き込んだとする。二人ともファイルをアップロードする。するとほとんどのシステムは自動的にマージを試みて、二人の変更が両方とも保持されるようにするだろう。

ではアリスとボブが二人とも、同じファイルの同じ行に変更を加えたとしよう。これはもう人の手を加えるしかない。アップロードが遅かった方の人に'''マージコンフリクト'''があったと伝えられ、どちらの変更を優先するか、あるいは行全体を修正し直すかを選ばなくてはいけない。

もっと複雑なケースもあるだろう。バージョン管理システムは簡単なケースは自動的に扱い、難しい物は人間に任せるようになっている。挙動は設定で変更できる場合が多い。

<references/>

{{Nav
|next=GitMagic/Chapter2
}}
