<!-- vim: set shiftwidth=4 wrap filetype=mediawiki: -->
{{#set: title=第3章 色んなクローン}}
{{Nav
|prev=GitMagic/Chapter2
|next=GitMagic/Chapter4
}}

= 第3章 色んなクローン =

以前のバージョン管理システムでは、ファイルを取得する主な方法はcheckoutだった。ある段階におけるファイルを入手するのだ。

Gitnなどのバージョン管理システムでは、主な方法はcloneだ。レポジトリをまるごとコピーするわけだ。言い換えると、中央サーバをミラーリングするのだ。メインのレポジトリでできることは何でも自分でもできる。

== 同期を取る ==

簡単なバックアップや同期には'''rsync'''圧縮ファイルでも我慢できますが、たまに、同じファイルをラップトップでもデスクトップでも編集して、その間に同期を取っていないようなことがある。

まず片方のマシンでgitレポジトリを作ってファイルをコミットする。そしてもう片方でコピーを作る。
 $ git clone other.computer:/path/to/files
ここからは、
 $ git commit -a
 $ git pull other.computer:/path/to/files HEAD
することでもうひとつのマシンのファイルを現在のマシンに「pull」できる。もし衝突が起こったらgitがそう教えてくれるので、それらのファイルを編集してからコミットしなおそう。

== 従来と同じソースコントロール ==

まずgitレポジトリを作成する。
 $ git init
 $ git add .
 $ git commit -m "Initial commit"

続いて中央サーバで、"Bare"レポジトリを作成する。
 $ mkdir proj.git
 $ cd proj.git
 $ git --bare init
 $ touch proj.git/git-daemon-export-ok

必要ならばGit daemonを起動する（既に起動してるかも）
 $ git daemon --detach  # it may already be running

自分のサーバではなくgitホスティングサービスを利用するなら、そのサイトのフォームに記入するなり何なり、支持に従おう。

これでローカルのレポジトリをサーバへ「push」できる。
 $ git push central.server/path/to/proj.git HEAD

これをチェックアウトするには、
 $ git clone central.server/path/to/proj.git

変更を加えたらまずローカルでコミットを作成する。
 $ git commit -a

リモートの最新の変更を入手する。
 $ git pull

もし衝突があったらそれらのファイルを編集して
 $ git commit -a

そしてローカルのコミットをサーバへチェックインする。
 $ git push

もしリモートが他の開発者によって更新されていたらpushは失敗するから、最新版をpullしなおして衝突を解消しよう。

ユーザはpullとpushをするためにはSSHアクセスが必要だが、ソースを入手するだけなら
 $ git clone git://central.server/path/to/proj.git
で誰でも入手できる（git daemonが走っていれば）。

gitプロトコルはHTTPのようなもので、普通は認証なしで誰でもプロジェクトをクローンできる。また、HTTPと同じく普通は認証なしでのpushはできない。


== クローズド・ソース ==

クローズド・ソースなプロジェクトを扱う場合は、前述のtouchコマンドを省く。また、'''git-daemon-export-ok'''というファイルを作成しないよう注意しよう。これでgitプロトコルによるアクセスができなくなり、SSHでしか見られなくなる。もし全部のプロジェクトがクローズドなら、そもそもgit daemonを走らせなくていい。


== "Bare"レポジトリ ==

レポジトリには2つの種類があり、ひとつは普通にinitして作成するもので、もうひとつは先程登場した"bare"レポジトリだ。"bare"（素の）とは、ワーキングディレクトリが存在しないレポジトリの事を言う。ここにはgitが内部的に使うファイル（普通のgitレポジトリの".git"というディレクトリに隠れているファイル）だけが存在する。履歴だけを管理していて、特定の状態のスナップショットは再現していないということだ。

"Bare"なレポジトリは集中バージョン管理における中央サーバのような役割をする。すなわち、プロジェクトのホームとして役立つ。開発者たちはそこからクローンし、オフィシャルな変更をpushする。普通、データを配布するためだけに存在することに成る。開発自体はクローン先で行われるのでワーキングディレクトリが必要ない。

多くのgitコマンドは、bareレポジトリに対して行うと失敗することがあるが、そんなときは環境変数'''GIT_DIR'''が正しくレポジトリを指しているか確認するのと、ちゃんと'''--bare'''オプションをつけているか確認するとよい。


== Push vs Pull ==

使い慣れたpullコマンドだけでなく、なぜpushコマンドも紹介したかというと、まずpullはbareレポジトリでは行えないからだ。代わりに'''fetch'''しなくてはいけない（後述）。それに、たとえbareでない普通のレポジトリを中央サーバに置いたとしても、そこでpullするのは面倒だからだ。まずサーバにログインして、pullする先のマシン（手元のマシンなど）のアドレスを調べてpullしなければならない。ファイアウォールなどの問題もあるだろうし、そもそもシェルアクセスができない場合も多いだろう。

これらの理由を抜きにしても、bareでないレポジトリへpushするのは避けたほうがいい。ワーキングディレクトリのあるレポジトリへpushすると混乱を招きやすいからだ。

要するに、宛先がbareレポジトリの場合だけpushを使い、それ以外はpullするのがよい。


== フォーク ==

何らかのプロジェクトのやり方が気に食わない？自分のほうがうまくできる？そんなときはサーバで
 $ git clone git://main.server/path/to/files
した上で、皆にこのフォークの事を伝えよう。

後々、元のプロジェクトの変更をこちらに適用したければpullできる。
 $ git pull


== 究極のバックアップ ==

プロジェクトのバックアップをいくつも、地理的にバラけさせて冗長に取っておきたい？プロジェクトに携わる開発者が多数いるなら、何もしなくて大丈夫だ。全てのクローンは実質的に完全なバックアップだからだ。現在の状況だけでなくそこへ至る全ての履歴も含んでいる。しかもハッシュ化のお陰で、誰かのクローンが壊れても、通信しようとするとすぐに検出される。

もしあまり人気のないプロジェクトなら、クローンをホスティングできるサーバをできるだけ多く見つけよう。

もし本当に気になるなら、最新のHEADのSHA1ハッシュをどこかに書き留めておこう。これは別にプライベートである必要はない。例えば新聞に載せるなどすると非常に効果的だと思う。攻撃者が新聞を全部書き換えるのは大変だろうから。


== 最速マルチタスク ==

いくつかの機能を同時に開発したいとしよう。そんなときはまずコミットしてから
 $ git clone . /some/new/directory
[http://en.wikipedia.org/wiki/Hard_link ハードリンク]という機能のお陰で、ローカルクローンは普通のバックアップより短時間で終わる。

これでそれぞれの機能を個別に、同時に作成できる。たとえば片方がコンパイル中にもう片方を編集できる。いつでももう片方のクローンから変更点をpullできる。
 $ git pull /the/other/clone HEAD

== ゲリラバージョン管理 ==

Subversionなど他のバージョン管理システムを使っていて、どうしてもgitを使いたくなったら？そんなときはまずワーキングディレクトリでgitレポジトリを作ろう。
 $ git init
 $ git add .
 $ git commit -m "Initial commit"

そしてそれをクローンする。
 $ git clone . /some/new/directory

で、そこで編集作業をすればいい。好きなだけgitの機能に頼れる。皆の変更内容を取り込みたい時は、まず元のワーキングディレクトリに移動し、svn updateなどで同期を取り、コミットする。
 $ git add .
 $ git commit -m "Sync with everyone else"

次に作業用ディレクトリに移り、
 $ git commit -a -m "Description of my changes"
 $ git pull

自分の側の変更を皆とシェアする（アップロードする）方法はgitでない側のバージョン管理システムによって変わるので、そちらで必要な作業をしよう。

多分もっとも優れた集中バージョン管理システムであるSubversionは、数えきれないほどのプロジェクトで使われている。'''git svn'''コマンドを使えば上記の作業を自動化してくれるので、ぜひ利用しよう。また、[http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html GitプロジェクトをSubversionへエクスポート]することもできる。

== Mercurial ==

Mercurialは分散バージョン管理システムの一つで、gitとはほぼシームレスに連携できる。'''hg-git'''プラグインを使えばMercurialユーザはなんの問題もなくgitレポジトリに対してpushとpullが行える。

hg-gitプラグインはgitなら
 $ git clone git://github.com/schacon/hg-git.git
Mercurialなら
 $ hg clone http://bitbucket.org/durin42/hg-git/
で入手できる。

残念ながら、同じ用途の逆のプラグイン（git用の、Mercurial連携プラグイン）は見たことがない。なのでたとえMercurialの方が好みだとしてもメインレポジトリにはgitを使うのをおすすめする。git中心のプロジェクトでは自然とMercurialユーザも参加できるのに対し、Mercurial中心のプロジェクトでは誰かがgitミラーを管理していなければならない。

プラグインを使うとMercurialレポジトリを空のレポジトリにpushすることでgitに変換できるが、'''hg-fast-export.sh'''スクリプトを使えばもっと簡単になる。
 $ git clone git://repo.or.cz/fast-export.git

変換するにはスクリプトを$PATHに入れてから、空のレポジトリで
 $ git init
 $ hg-fast-export.sh -r /hg/repo
とする。


== Bazaar ==

GitとMercurialに次いで人気のある分散バージョン管理システムBazaarについて簡単に述べておく。

Bazaarは比較的新しいソフトウェアなので、後発優位と言える。過去の失敗事例を見ているので回避が可能なのだ。それに、開発者たちはポータビリティとや他のバージョン管理システムとの連携性を重要視している。

'''bzr-git'''プラグインを使えばBazaarユーザはgitレポジトリとある程度連携できる。'''tailor'''というツールはBazaarレポジトリをgitレポジトリに（インクリメンタルに）変換できるshi,
'''bzr-fast-export'''なら一発で変換できる。


== 私がgitを使う理由 ==

私がそもそもgitを選んだのは、あの想像を絶するほど管理不能なLinuxカーネルソースを管理できていると聞いたからだ。それ以来、他のに乗り換える理由は見つかっていない。実によく働いてくれるし、まだ落とし穴で痛い目に遭ったこともない。主にLinuxを使うので別のプラットフォームで起こりうる問題も気にならない。

また、実行ファイルとしてPythonよりもCやbashスクリプトのほうが好きだというのもある。依存関係が少ないし、高速に動作するからだ。

Gitに改善の余地は見つからないわけではないし、自分でgitっぽいツールを書いてみようとしたこともあるが、あくまでも勉強のためだった。完成させていたとしてもきっとgitを使い続けただろうと思う。

もちろん、あなたのニーズは私とは異なるだろうから、他のシステムのほうが向いているというのは有りうる。でもGitを選んでおけばまず間違いないはずだ。

<references/>

{{Nav
|prev=GitMagic/Chapter2
|next=GitMagic/Chapter4
}}
